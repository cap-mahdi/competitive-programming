{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body wiint be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",`
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	
	"Meta hacker cup starting code":{
		"prefix":"metahackercup",
		"body":[
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp> // Common file",
			"#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update",
			"#include <ext/pb_ds/detail/standard_policies.hpp>",
			"#define int long long int",
			"#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"void no(){",
			"\tcout<<\"NO\"<<\"\\n\";",
			"}",
			"void yes(){",
			"\tcout<<\"YES\"<<\"\\n\";",
			"}",
			"",
			"void solve(){",
			"\t int n;",
			"\t cin>>n;",
			"\t vector<int> a(n);",
			"\t for(int i=0;i<n;i++){",
			"\t\t cin>>a[i];",
			"\t }",
			"\t$0",
			"}",
			"int32_t main(){",
			"    //fast I/O",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"freopen(\"input.txt\", \"r\", stdin);",
			"freopen(\"output.txt\", \"w\", stdout);",
			"    int t;",
			"    cin >> t;",
			"    for(int i=1;i<=t;i++){",
			"        cout<<\"Case #\"<<i<<\": \";",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
		],
	}
	,
	"Starting code with test cases":{
		"prefix":"solvewithtestcases",
		"body":[
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp> // Common file",
			"#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update",
			"#include <ext/pb_ds/detail/standard_policies.hpp>",
			"#define int long long int",
			"#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"void no(){",
			"\tcout<<\"NO\"<<\"\\n\";",
			"}",
			"void yes(){",
			"\tcout<<\"YES\"<<\"\\n\";",
			"}",
			"",
			"void solve(){",
			"\t int n;",
			"\t cin>>n;",
			"\t vector<int> a(n);",
			"\t for(int i=0;i<n;i++){",
			"\t\t cin>>a[i];",
			"\t }",
			"\t$0",
			"}",
			"int32_t main(){",
			"    //fast I/O",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    int t;",
			"    cin >> t;",
			"    while(t--){",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
		],
		"description": "Starting code with test cases"
	},
	"Starting code":{
		"prefix":"solve",
		"body":[
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp> // Common file",
			"#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update",
			"#include <ext/pb_ds/detail/standard_policies.hpp>",
			"#define int long long int",
			"#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"void no(){",
			"\tcout<<\"NO\"<<\"\\n\";",
			"}",
			"void yes(){",
			"\tcout<<\"YES\"<<\"\\n\";",
			"}",
			"",
			"void solve(){",
			"\t int n;",
			"\t cin>>n;",
			"\t vector<int> a(n);",
			"\t for(int i=0;i<n;i++){",
			"\t\t cin>>a[i];",
			"\t }",
			"\t$0",
			"}",
			"int32_t main(){",
			"    //fast I/O",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    solve();",
			"    return 0;",
			"}",
		],
		"description": "Starting code with test cases"
	},
	"Starting with test cases with I/O in file":{
		"prefix":"solvewithtestcasesfile",
		"body":[
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp> // Common file",
			"#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update",
			"#include <ext/pb_ds/detail/standard_policies.hpp>",
			"#define int long long int",
			"#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"void no(){",
			"\tcout<<\"NO\"<<\"\\n\";",
			"}",
			"void yes(){",
			"\tcout<<\"YES\"<<\"\\n\";",
			"}",
			"",
			"void solve(){",
			"\t int n;",
			"\t cin>>n;",
			"\t vector<int> a(n);",
			"\t for(int i=0;i<n;i++){",
			"\t\t cin>>a[i];",
			"\t }",
			"\t$0",
			"}",
			"int32_t main(){",
			"    //fast I/O",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"\n",
			"\t #ifndef ONLINE_JUDGE",			
			"freopen(\"input.txt\", \"r\", stdin);",
			"freopen(\"output.txt\", \"w\", stdout);",
			"\t#else",
			"    // online submission",
			"\t#endif",
			"\n",
			"    int t;",
			"    cin >> t;",
			"    while(t--){",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
		],
		"description": "Starting code with test cases with I/O in file"
	},
	"Starting with I/O in file":{
		"prefix":"solvefile",
		"body":[
			"#include <bits/stdc++.h>",
			"#include <ext/pb_ds/assoc_container.hpp> // Common file",
			"#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update",
			"#include <ext/pb_ds/detail/standard_policies.hpp>",
			"#define int long long int",
			"#define ordered_set tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
			"using namespace std;",
			"using namespace __gnu_pbds;",
			"",
			"void no(){",
			"\tcout<<\"NO\"<<\"\\n\";",
			"}",
			"void yes(){",
			"\tcout<<\"YES\"<<\"\\n\";",
			"}",
			"",
			"void solve(){",
			"\t int n;",
			"\t cin>>n;",
			"\t vector<int> a(n);",
			"\t for(int i=0;i<n;i++){",
			"\t\t cin>>a[i];",
			"\t }",
			"\t$0",
			"}",
			"int32_t main(){",
			"    //fast I/O",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"\n",
			"\t #ifndef ONLINE_JUDGE",			
			"freopen(\"input.txt\", \"r\", stdin);",
			"freopen(\"output.txt\", \"w\", stdout);",
			"\t#else",
			"    // online submission",
			"\t#endif",
			"\n",
			"     solve();",
			"    return 0;",
			"}",
		],
		"description": "Starting code with I/O in file"
	},
	"Bits manipulation":{
		"prefix":["bitsManipulation","getIthBit","setIthBit","clearIthBit","updateIthBit","clearLastIBits","clearRangeItoJ","replaceBits","checkPowerOf2","countSetBits","convertToBinary","complement","complementWithKBits"],
		"body":[
			"//Bits Manipulation",
			"int getIthBit(int n, int i){",
				"\treturn (n & (1 << i)) != 0;",
			"}\n",
			
			"void setIthBit(int &n, int i){",
				"\tn = n | (1 << i);",
			"}\n",
			
			"void clearIthBit(int &n, int i){",
				"\tn = n & (~(1 << i));",
			"}\n",
			
			"void updateIthBit(int &n, int i, int v){",
				"\tclearIthBit(n, i);",
				"\tn = n | (v << i);",
			"}\n",
			
			"void clearLastIBits(int &n, int i){",
				"\tint mask = (-1 << i);",
				"\tn=  n & mask;",
			"}\n",
			
			"void clearRangeItoJ(int &n, int i, int j){",
				"\tint a = (-1 << (j + 1));",
				"\tint b = (1 << i) - 1;",
				"\tint mask = a | b;",
				"\tn = n & mask;",
			"}\n",

			"void replaceBits(int &n, int m, int i, int j){",
				"//replacee i to j bits of n with m",
				"\tclearRangeItoJ(n, i, j);",
				"\tn = n | (m << i);",
				"}",
				
				"int checkPowerOf2(int n){ ",
				"\treturn (n & (n - 1)) == 0;",
				"}",
				
				"int countSetBits(int n){",
					"//complexity: O(no. of set bits)",
				"\tint count = 0;",
				"\twhile(n){",
					"\t//remove last set bit",
					"\tn = n & (n - 1);",
					"\tcount++;",
				"}",
				"\treturn count;\n",
				"//     //complexity: O(logn + 1) ",
				"// int count = 0;",
				"// while(n){",
				"//     count += (n & 1);",
				"//     n = n >> 1;",
				"// }",
				"// return count;",
				"}\n",
				
				"long long convertToBinary(int n){",
					"\tlong long ans = 0;",
					"\tlong long p = 1;",
					"\twhile(n){",
						"\tans += (n & 1) * p;",
						"\tp *= 10;",
						"\tn = n >> 1;",
					"}",
					"\treturn ans;",
				"}\n",
				"",
				"int complement(int n){",
					"\t//complement of n",
					"\tint noOfBits = log2(n) + 1;",
					"\tint mask = (1 << noOfBits) - 1;",
					"\treturn n ^ mask;",
				"}\n",
				"",
				"int complement(int n,int k)",
				"{",
					"\t//complement of n with k bits",
					"\tint mask = (1 << k) - 1;",
					"\treturn n ^ mask;",
				"}\n",
				"",
		],
		"description": "Bits manipulation"
	},
	"Big integer manipulation":{
		"prefix":"bigIntegerManipulation",
		"body":[
		"//Big Integer Manipulation",
		"void swap(string &a,string &b){",
			"\tstring temp = a;",
			"\ta = b;",
			"\tb = temp;",
		"}\n",
		
		"string addBigIntegers(string a,string b){",
			"\tif(a.length() > b.length())",
				"\tswap(a,b);",
			
			"\tstring result = \"\";",
		
			"\treverse(a.begin(),a.end());",
			"\treverse(b.begin(),b.end());",
		
			"\tint carry = 0;",
			"\tfor(int i = 0; i<a.length();i++){",
				"\tint sum = (a[i] - '0') + (b[i] - '0') + carry;",
				"\tresult.push_back(sum%10 + '0');",
				"\tcarry = sum/10;",
			"}",
		
			"\tfor(int i = a.length();i<b.length();i++){",
				"\tint sum = (b[i] - '0') + carry;",
				"\tresult.push_back(sum%10 + '0');",
				"\tcarry = sum/10;",
			"\t}",
		
			"\tif(carry)",
				"\tresult.push_back('1');",
			
			"\treverse(result.begin(),result.end());",
		
			"\treturn result;",
		"}\n",
		
		"string multiply(string a,int b){",
			"\tstring result = \"\";",
			"\tint carry = 0;",
			"\tfor(int i=a.length()-1;i>=0;i--){",
				"\tint product = (a[i] - '0') * b + carry;",
				"\tresult.push_back(product%10 + '0');",
				"\tcarry = product/10;",
			"}",
			"\twhile(carry){",
				"\tresult.push_back(carry%10 + '0');",
				"\tcarry = carry/10;",
			"\t}",
			"\treverse(result.begin(),result.end());",
			"\treturn result;",
		"}\n",
		
		"string bigFactorial(int n){",
			"\tstring result = \"1\";",
			"\tfor(int i=2;i<=n;i++){",
				"\tresult = multiply(result,i);",
			"\t}",
			"\treturn result;",
		"}",
	
	],
		"description": "Big integer manipulation"
	},
	"Matrix":{
		"prefix":"matrix",
		"body":[
			"class Mat {",
				"public:",
					"\tint n, m;",
					"\tvector<vector<int>> mat;",
					"\tMat(int n, int m){",
						"\t\tthis->n = n;",
						"\t\tthis->m = m;",
						"\t\tmat.resize(n, vector<int>(m, 0));",
					"\t}",
					
					"\tvoid identity(){",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tmat[i][i] = 1;",
						"\t\t}",
					"\t}\n",

					"\tvoid print(){",
						"\t\tcout<<\"Matrix \"<<n<<\" * \"<<m<<\"\\n\";",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tfor(int j = 0; j < m; j++){",
								"\t\t\t\tcout << mat[i][j] << \" \";",
							"\t\t\t}",
							"\t\t\tcout << \"\\n\";",
						"\t\t}",
					"\t}\n",

					"\tMat operator*(const Mat &other){",
						"\t\tMat res(n, other.m);",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tfor(int j = 0; j < other.m; j++){",
								"\t\t\t\tfor(int k = 0; k < m; k++){",
									"\t\t\t\t\tres.mat[i][j] += mat[i][k] * other.mat[k][j];",
								"\t\t\t\t}",
							"\t\t\t}",
						"\t\t}",
						"\t\treturn res;",
					"\t}\n",

					"\tMat operator^(int b){",
						"\t\tMat res(n, m);",
						"\t\tres.identity();",
						"\t\tMat a = *this;",
						"\t\twhile(b > 0){",
							"\t\t\tif(b & 1) res = res * a;",
							"\t\t\ta = a * a;",
							"\t\t\tb >>= 1;",
						"\t\t}",
						"\t\treturn res;",
					"\t}\n",

					"\tMat operator+(const Mat &other){",
						"\t\tMat res(n, m);",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tfor(int j = 0; j < m; j++){",
								"\t\t\t\tres.mat[i][j] = mat[i][j] + other.mat[i][j];",
							"\t\t\t}",
						"\t\t}",
						"\t\treturn res;",
					"\t}",
				"};",
		],
		"description": "Matrix"
	},
	"binaryExponentiation":{
		"prefix":["binaryExponentiation","linearRecurrence"],
		"body":[
			"int binpow(int a, int b) {",
				"\tint res = 1;",
				"\twhile (b > 0) {",
					"\t\tif (b & 1) res *= a;",
					"\t\ta *= a;",
					"\t\tb >>= 1;",
				"\t}",
				"\treturn res;",
			"}\n",
			"const int MOD = 1e9 + 7;\n",
			"long long int binpowwithmod(long long int a, long long int b){",
				"\tlong long int res = 1;",
				"\twhile(b > 0){",
					"\t\tif(b & 1) res = (res * a) % MOD;",
					"\t\ta = (a * a) % MOD;",
					"\t\tb >>= 1;",
				"\t}",
				"\treturn res;",
			"}\n",
			"long long int binmultiplywithmod(long long int a,long long int b,long long int c){",
				"\tlong long int res = 0;",
				"\twhile(b){",
					"\t\tif(b & 1) res = (res + a) % c;",
					"\t\ta = (a*2) % c;",
					"\t\tb >>= 1;",
				"\t}",
				"\treturn res;",
			"}\n",
			"//Linear Recurrence\n",
			"//Fibonnaci\n",
			"//import Matrix!!!!!!!!!!!!!!!\n",
			"int Fibonnaci(int n){",
				"\tMat a(2, 2);",
				"\ta.mat[0][0] = 1;",
				"\ta.mat[0][1] = 1;",
				"\ta.mat[1][0] = 1;",
				"\tn-=2;",
				"\ta = a^n;",
				"\treturn a.mat[0][0] + a.mat[0][1];",
			"}\n",
		],
		"description": "Binary Exponentiation"
	},
	"inputArray":{
		"prefix":"inputArray",
		"body":[
			"for(int i = 0; i < ${1:arraySize}; i++){",
				"\tcin >> ${2:arrayName}[i];",
			"}",
		],
		"description": "Input array"
	},
	"Fibonnaci":{
		"prefix":"Fibonnaci",
		"body":[
			"int Fibonnaci(int n){",
				"\tMat a(2, 2);",
				"\ta.mat[0][0] = 1;",
				"\ta.mat[0][1] = 1;",
				"\ta.mat[1][0] = 1;",
				"\tn-=2;",
				"\ta = a^n;",
				"\treturn a.mat[0][0] + a.mat[0][1];",
			"}",
		],
		"description": "nth Fibonnaci"
	},
	"prime isPrime and primeFactorisation":{
		"prefix":["prime","isPrime","primeFactorisation"],
		"body":[
			"// determine if a number is prime",
			"// complexity: O(sqrt(n))",
			"// used if you have to check if a number is prime or not for a single time",
			"bool isPrime(int n){",
				"\tif(n==1){",
					"\t\treturn false;",
				"\t}",
				"\tif(n==2){",
					"\t\treturn true;",
				"\t}",
				"\tif(n%2==0){",
					"\t\treturn false;",
				"\t}",
				"\tfor(int i=3;i*i<=n;i+=2){",
					"\t\tif(n%i==0){",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",
				"\treturn true;",
			"}\n",

			"// factorise a number into its prime factors",
			"// complexity: O(sqrt(n))",
			"// used if you have to factorise a number for a single time",
			"void factoriseOpt(int n){",
				"\tfor(int i=2;i*i<=n;i++){",
					"\t\tif(n%i==0){",
						"\t\t\tint count =0;",
						"\t\t\twhile(n%i == 0){",
							"\t\t\t\tcount++;",
							"\t\t\t\tn/=i;",
						"\t\t\t}",
						"\t\t\tcout<<i<<\"^\"<<count<<\",\";",
					"\t\t}",
				"\t}",
				"\tif(n!=1){",
					"\t\t cout<<n<<\"^\"<<1;",
				"\t}",
				"\tcout<<\"\\n\";",
			"}",
		],
		"description": "isPrime function + factorisin a prime"
	},
	"primeSieve":{
		"prefix":["primeSieve","primeSieveFactorisation","sieve","factoriseSieve"],
		"body":[
			"// determine if a number is prime",
			"// complexity: O(sqrt(n))",
			"// used if you have to check if a number is prime or not for multiple times (test cases)",
			"// precomputation: O(nloglogn)",
			"// space complexity: O(n)",
			"void primeSieve(vector<int> &sieve){",
				"\tsieve[2]=1; ",
				"\tfor(int i=3;i<=N;i+=2){",
					"\t\tsieve[i]=1;",
				"\t}",
				"\tfor(int i=3; i<=N;i++){",
					"\t\tif(sieve[i]){",
						"\t\t\t",
						"\t\t\tfor(int j=i*i;j<=N;j+=i){",
							"\t\t\t\tsieve[j]=0;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
			"\n",
			"// factorise a number into its prime factors",
			"// used if you have to factorise a number for multiple times (test cases)",
			"// precomputation: O(nloglogn)",
			"// the factorisation of a number can be done in O(logn) time",
			"// space complexity: O(n)",
			"vector<int> sieve(N+1,0);",
			"\n",
			"void primeSieveFactorisation(){",
				"\tfor(int i=2;i<=N;i+=2){",
					"\t\tsieve[i]=2;",
				"\t}",
				"\tfor(int i=3;i<=N;i++){",
					"\t\tif(sieve[i]==0){",
						"\t\t\tsieve[i]=i;",
						"\t\t\tfor(int j=i*i;j<=N;j+=i){",
							"\t\t\t\tif(sieve[j]==0)",
								"\t\t\t\t\tsieve[j]=i;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
			"\n",
			"void factoriseSieve(int n){",
				"\twhile(n!=1){",
					"\t\tint count =0;",
					"\t\tint prime = sieve[n];",
					"\t\twhile(n%prime == 0 ){",
						"\t\t\tcount++;",
						"\t\t\tn/=prime;",
					"\t\t}",
					"\t\tcout<<prime<<\"^\"<<count<<\",\";",
				"\t}",
			"}",

		],
		"description": "sieve of eratosthenes + factorising a number into its prime factors for testcases + deterline if a number is prime or not for testcases"
	},
	"segmentedSieve":{
		"prefix":["segmentedSieve"],
		"body":[
			"// segmented sieve",
			"// used to find prime numbers in a range [m,n] ",
			"// complexity: O(nloglogn + (n-m+1)*sqrt(n))",
			"// space complexity: O(sqrt(n))",
			"vector<int> sieve(N+1,0);",
			"vector<int> primes;",
			"void primeSieve(){",
				"\tsieve[2]=1; ",
				"\tprimes.push_back(2);",
				"\n",
				"\tfor(int i=3;i<=N;i+=2){",
					"\t\tsieve[i]=1;",
				"\t}",
				"\tfor(int i=3; i<=N;i++){",
					"\t\tif(sieve[i]){",
						"\t\t\tprimes.push_back(i);",
						"\t\t\tfor(int j=i*i;j<=N;j+=i){",
							"\t\t\t\tsieve[j]=0;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
			"\n",
			"\n",
			"void segmentedSieve(){",
				"\tint n,m;",
				"\tcin>>m>>n;",
				"\n",
				"\tvector<int>segment(n-m+1,0);",
				"\n",
				"\tfor(int p : primes){",
					"\t\tif(p*p>n){",
						"\t\t\tbreak;",
					"\t\t}",
					"\n",
					"\t\tint start =  (m/p) * p ;",
					"\n",
					"\t\tif(p>=m){",
						"\t\t\tstart = 2*p;",
					"\t\t}",
					"\t\tfor(int j=start;j<=n;j = j + p){",
						"\t\t\tif(j<m){",
							"\t\t\t\tcontinue;",
						"\t\t\t}",
						"\t\t\tsegment[j-m]=1;",
					"\t\t}",
					"\n",
					"\t\t",
				"\t}",
				"\tfor(int j=m;j<=n;j++){",
						"\t\tif(segment[j-m]==0){",
							"\t\t\tcout<<j<<\"\\n\";",
						"\t\t}",
					"\t}",
					"\tcout<<\"\\n\";",
			"}",
		],
		"description": "segmented sieve + used to find prime numbers in a range to avoid TLE or memory limit exceeded"
	},
	"euclid gcd and lcm":{
		"prefix":["euclid","gcd","lcm"],
		"body":[
			"// determine the gcd of two numbers in O(log(min(a,b))) complexity",
			"int gcd(int a,int b){",
				"\tif(b==0){",
					"\t\treturn a;",
				"\t}",
				"\treturn gcd(b,a%b);",
			"}",
			"//determine the lcm of two numbers in O(log(min(a,b))) complexity",
			"int lcm(int a,int b){",
				"\treturn (a*b)/gcd(a,b);",
			"}",
		],
		"description": "euclid's algorithm to determine gcd and lcm of two numbers"
	},
	"extended euclid for modular multiplicative inverse":{
		"prefix":["extended","euclid","modulatMultiplicativeInverse","MMI","extendedEuclid","extendedGCD"],
		"body":[
			"//return the {x,y,gcd} such that ax + by = gcd(a,b), it uses the extended euclidean algorithm, is is done in O(log(min(a,b))) complexity",
			"vector<int> extendedGCD(int a,int b){",
				"\tif(b==0){",
					"\t\treturn {1,0,a};",
				"\t}",
				"\tvector <int> result = extendedGCD(b,a%b);",
				"\tint x1 = result[0];",
				"\tint y1 = result[1];",
				"\tint gcd = result[2];",
				"\treturn {y1, x1 - (a/b)*y1,gcd};",
				"\t",
			"}",
			"// print the modular multiplicative inverse of a modulo m if it exists, it uses the extended euclidean algorithm, is is done in O(log(min(a,b))) complexity",
			"//it finds x such that ax = 1 (mod m) if a and m are coprime",
			"void MMI(int a,int m){",
			"\t /! if m is prime then we can use fermat's little theorem to find the multiplicative modulo inverse of a modulo m call the snippet ModuloArithmetic.cpp",
				"\tvector<int> result = extendedGCD(a,m);",
				"\tint x = result[0];",
				"\tint gcd = result[2];",
				"\tif(gcd!=1){",
					"\t\tcout<<\"Multiplicative modulo inverse does not exist\"<<\"\\n\";",
				"\t}",
				"\telse{",
					"\t\tint ans = (x%m + m)%m;//to make sure that ans is in the range [0,b-1]",
					"\t\tcout<<\"Multiplicative modulo inverse is \"<<ans<<\"\\n\";",
				"\t}",
			"}",
		],
		"description": "extended euclid's algorithm to determine modular multiplicative inverse of a modulo m"
	},
	"extended linear diophantine equation": {
		"prefix": ["linear", "diophantine", "equation", "solutionForLinearDiophantine"],
		"body": [
			"// Return the {x, y, gcd} such that ax + by = gcd(a, b)",
			"// It uses the extended Euclidean algorithm and has a complexity of O(log(min(a, b)))",
			"vector<int> extendedGCD(int a, int b) {",
			"\tif (b == 0) {",
			"\t\treturn {1, 0, a};",
			"\t}",
			"\tvector<int> result = extendedGCD(b, a % b);",
			"\tint x1 = result[0];",
			"\tint y1 = result[1];",
			"\tint gcd = result[2];",
			"\treturn {y1, x1 - (a / b) * y1, gcd};",
			"}",
			"",
			"// Print the integral solution of ax + by = c if it exists",
			"// It uses the extended Euclidean algorithm and has a complexity of O(log(min(a, b)))",
			"void solutionForLinearDiophantine(int a, int b, int c) {",
			"\tvector<int> result = extendedGCD(a, b);",
			"\tint x0 = result[0];",
			"\tint y0 = result[1];",
			"\tint gcd = result[2];",
			"",
			"\tif (c % gcd) {",
			"\t\tcout << \"There is no solution\" << \"\\n\";",
			"\t\treturn;",
			"\t}",
			"",
			"\tint k = c / gcd;",
			"\tint a1 = a / gcd;",
			"\tint b1 = b / gcd;",
			"\tcout << \"x = \" << x0 << \" + k*\" << b1 << \"\\n\";",
			"\tcout << \"y = \" << y0 << \" - k*\" << a1 << \"\\n\";",
			"}"
		],
		"description": "Solving a linear Diophantine equation using the extended Euclidean algorithm"
	},
	"modulo arithmatic": {
		"prefix": ["ModuloArithmatic","modulo", "addmod", "submod", "multiplymod", "powermod", "modInverse", "divideMod", "calculateFactorialMod", "nCr", "nPr","combination","permutation"],
		"body": [
			"const int P = 1e9 + 7 ;//it shoud be prime number because we are using fermat's little theorem whichi is only applicable for prime numbers",
			"//the theoreme is : a^(p-1) = 1 (mod p) where p is prime number and a is any number so  we can write a^(p-2) = a^(-1) (mod p) which is the inverse of a",
			"const int N = 1e5 ;",
			"int fact[N];",
			"",
			"int addmod(int a, int b){",
			"\treturn (a + b) % P;",
			"}",
			"",
			"int submod(int a, int b){",
			"\treturn (a - b + P) % P;// to make sure the remainder is in the range [0, P-1]",
			"}",
			"",
			"int multiplymod(int a, int b){",
			"\treturn (a * b) % P;//a and b must be long long int because at worst case a*b can be 1e18 which cannot be stored in int",
			"}",
			"",
			"int powermod(int a, int b){",
			"\t//it determines a^b (mod p)",
			"\t//fast exponentiation in O(log(b))",
			"\tint res = 1;",
			"\twhile(b){",
			"\t\tif(b & 1){",
			"\t\t\tres = multiplymod(res, a);",
			"\t\t}",
			"\t\ta = multiplymod(a, a);",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"int modInverse(int a){",
			"\t//it determines  a^(-1) (mod p)",
			"\t///O(log(P ))",
			"\t//using fermat's little theorem",
			"\treturn powermod(a, P - 2);",
			"}",
			"",
			"int divideMod(int a, int b){",
			"\t// it determines a/b (mod p)",
			"\t//O(log(P ))",
			"\t//a/b = a * (b^(-1)) (mod p) = a * (b^(p-2)) (mod p)",
			"\treturn multiplymod(a, modInverse(b));",
			"}",
			"",
			"int calculateFactorialMod(){",
			"\t// it determines the factorial of all numbers from 0 to N (mod p)",
			"\t//O(N) ",
			"\tfact[0] = 1;",
			"\tfor(int i = 1; i <= N; i++){",
			"\t\tfact[i] = multiplymod(fact[i - 1], i);",
			"\t}",
			"}",
			"",
			"int nCr(int n, int r){",
			"\t//it determines nCr (mod p)",
			"\t//O(log(P ))",
			"\t//nCr = n! / (r! * (n - r)!)",
			"\t//nCr = n! * (r! * (n - r)!)^(-1) (mod p)",
			"\t//nCr = n! * (r! * (n - r)!)^(p - 2) (mod p)",
			"\tint numerator = fact[n];",
			"\tint denominator = multiplymod(fact[r], fact[n - r]);",
			"\treturn multiplymod(numerator, modInverse(denominator));",
			"}",
			"",
			"int nPr(int n, int r){",
			"\t//it determines nPr (mod p)",
			"\t//O(log(P ))",
			"\t//nPr = n! / (n - r)! because nPr = n * (n - 1) * (n - 2) * ... * (n - r + 1)",
			"\t//nPr = n! * (n - r)!^(-1) (mod p)",
			"\t//nPr = n! * (n - r)!^(p - 2) (mod p)",
			"\tint numerator = fact[n];",
			"\tint denominator = fact[n - r];",
			"\treturn multiplymod(numerator, modInverse(denominator));",
			"}"
		],
		"description": "modular arithmatic for addition, subtraction, multiplication, power, inverse, division, factorial, nCr, nPr"
	},
	"Chinese remainder theorem":{
		"prefix": ["ChineseRemainderTheorem", "chineseRemainder", "CRT"],
		"body": [
			"int multiplymod(int a, int b){",
			"\treturn (a * b) % mod ;//a and b must be long long int because at worst case a*b can be 1e18 which cannot be stored in int",
			"}",
			"",
			"int powermod(int a, int b){",
			"\t//fast exponentiation in O(log(b))",
			"\tint res = 1;",
			"\twhile(b){",
			"\t\tif(b & 1){",
			"\t\t\tres = multiplymod(res, a);",
			"\t\t}",
			"\t\ta = multiplymod(a, a);",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"int modInverse(int a, int p){",
			"\t///O(log(P))",
			"\t// if P is prime then you can directly find the modulo inverse of a using fermat's little theorem",
			"\t//using fermat's little theorem",
			"\treturn powermod(a, p-2);",
			"}",
			"void ChineseRemainderTheorem(int * primes ,int * remainders,int n){",
			"\tint N = 1;",
			"\tfor(int i = 0; i < n; i++){",
			"\t\tN *= primes[i];",
			"\t}",
			"\tint result = 0;",
			"\tfor(int i = 0; i < n; i++){",
			"\t\tint Ni = (N / primes[i]);",
			"\t\tint x = multiplymod(remainders[i], modInverse(Ni % primes[i], primes[i]));",
			"\t\tresult += multiplymod(x, Ni);",
			"\t}",
			"\tcout << result % N << \" + k*\" << N  << \"\\n\";",
			"",
			"}"
		],
		"description": "Chinese remainder theorem, finding the smallest positive value of x such that x % p[i] = r[i] for all i such that p[i] and p[j] are coprime for all i != j"
	},
	"Euler's Totient Function":{
		"prefix": ["EulerTotientFunction", "EulerTotient", "EulerPhi","count_numbers_with_gcd","countNumbersWithGCD","count_numbers_less_than_n_with_gcd"],
		"body": [
			"const int N = 1e6+5;",
			"",
			"int phi[N];",
			"void calcul_totient(){",
			"\t//calculating phi for all numbers from 1 to N",
			"\t//Complexity: O(NloglogN)",
			"\tiota(phi,phi+N,0);",
			"\tfor(int i=2;i<N;i++){",
			"\t\tif(phi[i]==i){",
			"\t\t\tfor(int j=i;j<N;j+=i){",
			"\t\t\t\tphi[j] -= phi[j]/i;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
			"",
			"int count_numbers_less_than_n_with_gcd(int n,int g){",
			"\tif(n%g!=0) return 0;",
			"\treturn phi[n/g];",
			"}"
		],
		"description": "Euler's Totient Function, it is used to find the number of numbers from 1 to n which are coprime with n, it is also used to find the number of numbers from 1 to n such that gcd(i,n) = g"
	},
	"Binomial Coefficient":{
		"prefix": ["BinomialCoefficient", "binomialCoefficient", "nCr", "nCrDP", "nCrDynamicProgramming"],
		"body": [
			"const int N = 1e5;",
			"vector<vector<int>> binomialCoefficients(N+1, vector<int>(1,0));",
			"//nCk = binomialCoefficients[n][k]",
			"//used if you need nCk or binomialCoefficients[n][k] for multiple queries",
			"void computeBinomialCoefficients(){",
			"\t//O(n^2)",
			"\tfor(int i=0; i<=N; i++){",
			"\t\tbinomialCoefficients[i][0] = 1;",
			"\t\tfor(int j=1; j<i; j++){",
			"\t\t\tbinomialCoefficients[i].push_back(binomialCoefficients[i-1][j-1] + binomialCoefficients[i-1][j]);",
			"\t\t}",
			"\t\tbinomialCoefficients[i].push_back(1);",
			"\t}",
			"}",
			"",
			"int nCr(int n,int k){",
			"\t return binomialCoefficients[n][k];",
			"}",
			"const int P = 1e9 + 7;",
			"int fact[N];",
			"int multiplymod(int a, int b){",
			"\treturn (a * b) % P;//a and b must be long long int because at worst case a*b can be 1e18 which cannot be stored in int",
			"}",
			"int calculateFactorialMod(){",
			"\t//O(N) ",
			"\tfact[0] = 1;",
			"\tfor(int i = 1; i <= N; i++){",
			"\t\tfact[i] = multiplymod(fact[i - 1], i);",
			"\t}",
			"}",
			"int nPr(int n,int k){",
			"\treturn binomialCoefficients[n][k]*fact[k];",
			"}"

		],
			"description": "Binomial Coefficient, it is used to find the value of nCr, it can be computed using dynamic programming in O(n^2) time and O(n^2) space"
	},
	"Generating all nCk subsets using prev_permutation":{
		"prefix": ["nCkSubsets"],
		"body": [
			"// Generate all possible subsets of size K or NCK subsets",
			"void comp(int N, int K, vector<int>& a) {",
			"    string bitMask(K, '1');",
			"    bitMask.resize(N, '0');//complete the bit mask with 0's",
			"    do {",
			"        vector<int> subset;",
			"        for (int i = 0;i < N;i++) {",
			"            if (bitMask[i] == '1') {",
			"                subset.push_back(a[i]);",
			"                cout << a[i] << \" \";",
			"            }",
			"        }",
			"        cout << \"\\n\";",
			"        //process subset",
			"    } while (prev_permutation(bitMask.begin(), bitMask.end()));",
			"}",
		],
		"description": "Generating all nCk subsets using prev_permutation"
	},

	"Generating subsets and permutation using BackTracking and recursion":{
		"prefix": ["subsets", "permutations", "subsetsRecursion", "permutationsRecursion", "subsetsBackTracking", "permutationsBackTracking","BackTracking"],
		"body": [
			"// generating all subsets of a string using recursion in O(2^n)" ,
			"//the call will be subsets(s,\"\",0,s.size())",
			"void subsets(string s,string output,int i,int n){",
			"\t//base case",
			"\tif(i==n){",
			"\t\tcout<<output<<\"\\n\";",
			"\t\treturn;",
			"\t}",
			"",
			"\t//recursive case",
			"\tsubsets(s,output,i+1,n);",
			"\toutput.push_back(s[i]);",
			"\tsubsets(s,output,i+1,n);",
			"}",
			"",
			"// generating all permutations of a string using recursion in O(n * n!)",
			"//the call will be permutations(s,0,s.size())",
			"void permutations(string s,int i,int n){",
			"\t//base case",
			"\tif(i==n){",
			"\t\tcout<<s<<\"\\n\";",
			"\t\treturn;",
			"\t}",
			"",
			"\t//recursive case",
			"\tfor(int j=i;j<n;j++){",
			"\t\tswap(s[i],s[j]);",
			"\t\tpermutations(s,i+1,n);",
			"\t\tswap(s[i],s[j]);",
			"\t}",
			"}"
		],
		"description": "Generating subsets and permutation using BackTracking"
	},
	"Binary Search":{
		"prefix": ["binarySearch", "lowerBound", "upperBound", "occurence","occurrenceInSortedArray","lowerBoundInSortedArray","upperBoundInSortedArray"],
		"body": [
			"int binarySearch(vector<int> v,int key){",
			"\t//find the index of the key in the sorted array",
			"\t//O(logn)",
			"\tint n = v.size();",
			"\tint start = 0;",
			"\tint end = n-1;",
			"\twhile(start<=end){",
			"\t\tint mid = (start+end)/2;",
			"\t\tif(v[mid]==key){",
			"\t\t\treturn mid;",
			"\t\t}",
			"\t\telse if(v[mid]>key){",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t}",
			"\treturn -1;",
			"}",
			"",
			"int lowerBound(vector<int> v,int key){",
			"\t//lower bound is the first index where the key is present in a sorted array",
			"\t//O(logn)",
			"\tint n = v.size();",
			"\tint start = 0;",
			"\tint end = n-1;",
			"\tint ans = -1;",
			"\twhile(start<=end){",
			"\t\tint mid = (start+end)/2;",
			"\t\tif(v[mid]==key){",
			"\t\t\tans = mid;",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse if(v[mid]>key){",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"int upperBound(vector<int> v,int key){",
			"\t//upper bound is the last index where the key is present in a sorted array",
			"\t// O(logn)",
			"\tint n = v.size();",
			"\tint start = 0;",
			"\tint end = n-1;",
			"\tint ans = -1;",
			"\twhile(start<=end){",
			"\t\tint mid = (start+end)/2;",
			"\t\tif(v[mid]==key){",
			"\t\t\tans = mid;",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t\telse if(v[mid]>key){",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"int occurence(vector<int> v,int key){",
			"\t//find the number of occurences of the key in the sorted array",
			"\t//O(logn)  ",
			"\tint lower = lowerBound(v,key);",
			"\tint upper = upperBound(v,key);",
			"\tif(lower==-1) return 0;",
			"\treturn upper-lower+1;",
			"}"
		],
		"description": "binary search used to binary search, lower bound, upper bound and occurence of a key in a sorted array" 
	},
	"Merge Sort":{
		"prefix": ["mergeSort"],
		"body": [
			"void merge(vector<int> &arr,int s,int e){",
			"\t//O(n)",
			"\tvector<int> temp;",
			"\tint mid = (s + e) / 2;",
			"\tint i = s;",
			"\tint j = mid + 1;",
			"\twhile(i <= mid && j <= e){",
			"\t\tif(arr[i] < arr[j]){",
			"\t\t\ttemp.push_back(arr[i++]);",
			"\t\t}",
			"\t\telse{",
			"\t\t\ttemp.push_back(arr[j++]);",
			"\t\t}",
			"\t}",
			"",
			"\twhile(i <= mid){",
			"\t\ttemp.push_back(arr[i]);",
			"\t\ti++;",
			"\t}",
			"",
			"\twhile(j <= e){",
			"\t\ttemp.push_back(arr[j]);",
			"\t\tj++;",
			"\t}",
			"\t",
			"\tint k = 0;",
			"\tfor(int idx = s; idx <= e; idx++){",
			"\t\tarr[idx] = temp[k++];",
			"\t}",
			"",
			"}",
			"",
			"void mergeSort(vector<int> &arr,int s,int e){",
			"\t//sort the array in the range [s,e]",
			"\t//O(nlogn)",
			"\t//base case",
			"\tif(s >= e){",
			"\t\treturn;",
			"\t}",
			"",
			"\t//recursive case",
			"\t//divide",
			"\tint mid = (s + e) / 2;",
			"\tmergeSort(arr, s, mid);",
			"\tmergeSort(arr, mid + 1, e);",
			"\tmerge(arr, s, e);",
			"}"
		],
		"description": "Merge Sort is a divide and conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. The merge() function is used for merging two halves."
	},
	"Quick Sort":{
		"prefix": ["quickSort"],
		"body": [
			"int partition(vector<int> &arr, int s, int e){",
			"\t// O(n)",
			"\tint pivot = arr[e];",
			"\tint i = s - 1;",
			"\tfor (int j = s; j < e; j++){",
			"\t\tif (arr[j] < pivot){",
			"\t\t\ti++;",
			"\t\t\tswap(arr[i], arr[j]);",
			"\t\t}",
			"\t}",
			"\tswap(arr[i + 1], arr[e]);",
			"\treturn i + 1;",
			"}",
			"void quickSort(vector<int> &arr, int s, int e){",
			"\t//sort the array in the range [s,e]",
			"\t// O(nlogn) to O(n^2)",
			"\t// base case",
			"\tif (s >= e){",
			"\t\treturn;",
			"\t}",
			"",
			"\t// recursive case",
			"\t// divide",
			"\tint p = partition(arr, s, e); // return the index of the pivot element placed in the correct position",
			"\t// conquer",
			"\tquickSort(arr, s, p - 1);",
			"\tquickSort(arr, p + 1, e);",
			"}"
		],
		"description": "Quick Sort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot."
	},
	"quickSelect":{
		"prefix": "quickSelect",
		"body": [
			"//****quick select",
			"int partition(vector<int> &arr, int s, int e){",
			"\t//divide the array into two parts such that all the elements in the left part are smaller than the pivot element and all the elements in the right part are greater than the pivot element",
			"\t// O(n)",
			"\tint pivot = arr[e];",
			"\tint i = s - 1;",
			"\tfor (int j = s; j < e; j++){",
			"\t\tif (arr[j] < pivot){",
			"\t\t\ti++;",
			"\t\t\tswap(arr[i], arr[j]);",
			"\t\t}",
			"\t}",
			"\tswap(arr[i + 1], arr[e]);",
			"\treturn i + 1;",
			"}",
			"",
			"int quickSelect(vector<int> &arr, int s, int e, int k){",
			"\t//find the kth smallest element in the array",
			"\t// O(n) to O(n^2)",
			"\t// base case",
			"\tif (s >= e){",
			"\t\treturn -1;",
			"\t}",
			"",
			"\t// recursive case",
			"\tint p = partition(arr, s, e);",
			"\tif (p + 1 == k){",
			"\t\treturn arr[p];",
			"\t}",
			"\telse if (p > k){",
			"\t\treturn quickSelect(arr, s, p - 1, k);",
			"\t}",
			"\telse{",
			"\t\treturn quickSelect(arr, p + 1, e, k);",
			"\t}",
			"}"
		],
		"description": "Quick Select is a selection algorithm to find the kth smallest element in an unordered list. It is related to the quick sort sorting algorithm."
	},
	"Ternary search":{
		"prefix": "ternarySearch",
		"body": [
			"double ternarySeachForMin(double s, double e){",
			"\t// find the minimum of the parabola f THAT SHOULD BE DEFINED in the range [s,e]",
			"\t// O(log(3/2)n)",
			"\tdouble eps = 1e-6;",
			"\t// cout<< setprecision(10)<<fixed; if you fixed it to 10 decimal places you won't get 6 ",
			"\twhile (e - s > eps)",
			"\t{",
			"\t\t// cout << s << \" \" << e << \" \" << e-s << \" \" << (e-s)/3 << endl;",
			"\t\tdouble mid1 = s + (e - s) / 3;",
			"\t\tdouble mid2 = e - (e - s) / 3;",
			"\t\tif (parabola(mid1) < parabola(mid2))",
			"\t\t{",
			"\t\t\te = mid2;",
			"\t\t}",
			"\t\telse",
			"\t\t{",
			"\t\t\ts = mid1;",
			"\t\t}",
			"\t}",
			"\treturn s;",
			"}",
			"",
			"int ternarySeach(vector<int> arr, int s, int e){",
			"\t// find the maximum of the array in the range [s,e],this array should increase then decrease",
			"\t// O(log(3/2)n)",
			"\twhile(s <= e){",
			"\t\tint mid1 = s + (e - s) / 3;",
			"\t\tint mid2 = e - (e - s) / 3;",
			"\t\tif(arr[mid1] < arr[mid2]){",
			"\t\t\ts = mid1 + 1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\te = mid2 - 1;",
			"\t\t}",
			"\t}",
			"\treturn arr[s];",
			"}"
		],
		"description": "Ternary search is a divide and conquer algorithm that can be used to find an element in an array. It is similar to binary search where we divide the array into two parts but in this algorithm, we divide the given array into three parts and determine which has the key (searched element)."
	},
	"Counting Sort":{
		"prefix": "countingSort",
		"body": [
			"void countingSort(int a[],int size, int m, int n){",
			"\t//sorting the array in O(N) time.",
			"\t//assuming the range of the elements in the array is [m,n]",
			"",
			"\tint freq[n-m+1] = {0};",
			"\t//frequency of each element in the array.",
			"\tfor(int i = 0;i<size;i++){",
			"\t\tfreq[a[i]-m]++;",
			"\t}",
			"",
			"\t//prefix sum array of freq",
			"\tfor(int i=1;i<=n-m;i++){",
			"\t\tfreq[i]+=freq[i-1];",
			"\t}",
			"",
			"\tint ans[size];",
			"\t//from the end of the array to maintain stability,we are using freq[a[i]-m]-1 as the index then decrementing freq[a[i]-m]",
			"\tfor(int i = size-1;i>=0;--i){",
			"\t\tans[freq[a[i]-m]-1] = a[i];",
			"\t\tfreq[a[i]-m]--;",
			"\t}",
			"",
			"\t//copying the sorted array to the original array.",
			"\tfor(int i = 0;i<size;i++){",
			"\t\ta[i] = ans[i];",
			"\t}",
			"",
			"}"
		],
		"description": "Counting sort is a sorting technique based on keys between a specific range. It works by counting the number of objects having distinct key values (kind of hashing). Then doing some arithmetic to calculate the position of each object in the output sequence."
	},
	"Count number of elements of sorted array in range":{
		"prefix": ["countNumberOfElementsInRange","countNumberOfElementsInSortedArrayInRange","countNumberOfElements"],
		"body": [
			"int count_number_of_elements_in_range(int a[], int N, int l, int r) {",
			"\t//returns the number of elements in the SORTED array whose value lies in the range [l,r]",
			"\t//O(logN)",
			"\treturn upper_bound(a, a + N, r) - lower_bound(a, a + N, l);",
			"}"
		],
		"description": "Count number of elements of sorted array in range [l, r]"
	},
	"Segment Tree":{
		"prefix": "segmentTree",
		"body": [
			"//example of segment tree for sum of range",
			"struct segmenttree {",
    		"//we use this structure in case we have an array and multiple queries and after each query we have to update an element of an array ",
			"\tint n;",
			"\tvector<int> st;",
			"",
			"\tvoid init(int _n) {",
			"\t\tthis->n = _n;",
			"\t\tst.resize(4 * n, 0);//TODO: fill it with IDENTITY ELEMENT(in this case it is 0 for sum)",
			"\t}",
			"",
			"\tvoid build(int start, int ending, int node, vector<int> &v) {",
			"\t\t// leaf node base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = v[start];",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\t// left subtree is (start,mid)",
			"\t\tbuild(start, mid, 2 * node + 1, v);",
			"",
			"\t\t// right subtree is (mid+1,ending)",
			"\t\tbuild(mid + 1, ending, 2 * node + 2, v);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the question (in this case it is sum)",
			"\t}",
			"",
			"\tint query(int start, int ending, int l, int r, int node) {",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn 0;//TODO: return the IDENTITY ELEMENT (in this case it is 0 for sum)",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\treturn st[node];",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tint q1 = query(start, mid, l, r, 2 * node + 1);",
			"\t\tint q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
			"",
			"\t\treturn q1 + q2;//TODO: change the operation according to the question (in this case it is sum)",
			"\t}",
			"",
			"\tvoid update(int start, int ending, int node, int index, int value) {",
			"\t\t// base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = value;",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"\t\tif (index <= mid) {",
			"\t\t\t// left subtree",
			"\t\t\tupdate(start, mid, 2 * node + 1, index, value);",
			"\t\t}",
			"\t\telse {",
			"\t\t\t// right",
			"\t\t\tupdate(mid + 1, ending, 2 * node + 2, index, value);",
			"\t\t}",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the question (in this case it is sum)",
			"",
			"\t\treturn;",
			"\t}",
			"",
			"\tvoid build(vector<int> &v) {",
			"\t\t// O(n)",
			"\t\tbuild(0, n - 1, 0, v);",
			"\t}",
			"",
			"\tint query(int l, int r) {",
			"\t\t// O(logn)",
			"\t\treturn query(0, n - 1, l, r, 0);",
			"\t}",
			"",
			"\tvoid update(int x, int y) {",
			"\t\t// O(logn)",
			"\t\tupdate(0, n - 1, 0, x, y);",
			"\t}",
			"};",
		],
		"description": "segment tree structure used if we have an array and multiple queries and after each query we have to update an element  of an array"
	},
	"Segment tree with lazy propagation":{
		"prefix": "segmentTreeWithLazyPropagation",
		"body": [
			"struct segmentTreeWithLazyPropagation {",
			"\t//we use this structure in case we have an array and multiple queries and after each query we have to update a range of array ",
			"\tint n;",
			"\tvector<int> st, lazy;",
			"",
			"\tvoid init(int _n) {",
			"\t\tthis->n = _n;",
			"\t\tst.resize(4 * n, 0);//TODO: fill the st with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\tlazy.resize(4 * n, 0);//TODO: fill the lazy with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t}",
			"",
			"\tvoid build(int start, int ending, int node, vector<int>& v) {",
			"\t\t// leaf node base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = v[start];",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\t// left subtree is (start,mid)",
			"\t\tbuild(start, mid, 2 * node + 1, v);",
			"",
			"\t\t// right subtree is (mid+1,ending)",
			"\t\tbuild(mid + 1, ending, 2 * node + 2, v);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the problem (in this case it is sum)",
			"\t}",
			"",
			"\tint query(int start, int ending, int l, int r, int node) {",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn 0;//TODO: return the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t}",
			"",
			"\t\t// lazy propagation / clear the lazy update",
			"\t\tif (lazy[node] != 0) {//TODO: compare with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t\t// pending updates",
			"\t\t\t// update the segment tree node",
			"\t\t\t//TODO: change the operation according to what he is doing in the range update (in this case it is adding same value to all the elements in the range)",
			"\t\t\tst[node] += lazy[node] * (ending - start + 1);//3andou dayn lzem ikahlsou que ce soit ken bech yetla3 houwa complete case wla 9bal mayebaath el wledou",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\t//TODO: change the operation according to the problem (in this case the lazy contains the value to be added to all the elements in the range)",
			"\t\t\t\tlazy[2 * node + 1] += lazy[node];",
			"\t\t\t\tlazy[2 * node + 2] += lazy[node];",
			"\t\t\t}",
			"\t\t\tlazy[node] = 0;//TODO: assign the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\treturn st[node];",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tint q1 = query(start, mid, l, r, 2 * node + 1);",
			"\t\tint q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
			"",
			"\t\treturn q1 + q2;//TODO: change the operation according to the problem (in this case it is sum)",
			"\t}",
			"",
			"\tvoid update(int start, int ending, int node, int l, int r, int value) {",
			"\t\t// lazy propagation / clear the lazy update",
			"\t\tif (lazy[node] != 0) {//TODO: compare with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t\t// pending updates",
			"\t\t\t// update the segment tree node",
			"\t\t\t//TODO: change the operation according to what he is doing in the range update (in this case it is adding same value to all the elements in the range)",
			"\t\t\tst[node] += lazy[node] * (ending - start + 1);//we can not do this in case of partial case be cause we will update this value at the end of the function",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\t//TODO: change the operation according to the problem (in this case the lazy contains the value to be added to all the elements in the range)",
			"\t\t\t\tlazy[2 * node + 1] += lazy[node];",
			"\t\t\t\tlazy[2 * node + 2] += lazy[node];",
			"\t\t\t}",
			"\t\t\tlazy[node] = 0;//TODO: assign the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t}",
			"",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\t// update the segment tree node",
			"\t\t\tst[node] += value * (ending - start + 1);//TODO: change the operation according to what he is doing in the range update (in this case it is adding same value to all the elements in the range)",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\t//TODO: change the operation according to the problem (in this case the lazy contains the value to be added to all the elements in the range)",
			"\t\t\t\tlazy[2 * node + 1] += value;",
			"\t\t\t\tlazy[2 * node + 2] += value;",
			"\t\t\t}",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tupdate(start, mid, 2 * node + 1, l, r, value);",
			"\t\tupdate(mid + 1, ending, 2 * node + 2, l, r, value);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the problem (in this case it is sum)",
			"\t}",
			"",
			"\tvoid build(vector<int>& v){",
			"\t\t//O(n)",
			"\t\tbuild(0, n - 1, 0, v);",
			"\t}",
			"",
			"\tint query(int l, int r){",
			"\t\t//O(logn) ",
			"\t\treturn query(0, n - 1, l, r, 0);",
			"\t}",
			"",
			"\tvoid update(int l, int r, int value){",
			"\t\t//O(logn), it is know to close to query implementation not like the simple segment tree",
			"\t\tupdate(0, n - 1, 0, l, r, value);",
			"\t}",
			"};"],
			"description": "Segment Tree with Lazy Propagation used if we have an array and multiple queries and after each query we have to update a range of array",
	},
	"fenwick tree":{
		"prefix": ["fenwick","fenwickTree","binaryIndexedTree"],
		"body": [
			"//example of a fenwick tree for range sum queries",
			"struct fenwick {",
			"\t//It used like segment tree but it is more efficient in terms of space and time",
			"\t//it is also called binary indexed tree",
			"\t//It has limitations",
			"\t//It does not support range updates",
			"\t//Advantage: easy to understand and code (it takes only 10 lines of code)",
			"\tvector<int> fn;",
			"\tint n;",
			"",
			"\tvoid init(vector<int> v) {",
			"\t\tthis->n = v.size() + 1;//1 based indexing",
			"\t\tfn.resize(this->n, 0);//fill it with IDENTITY element",
			"\t\tfor (int i = 0; i < v.size(); i++) {",
			"\t\t\tthis->add(i, v[i]);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid init(int n) {",
			"\t\tthis->n = n + 1;//1 based indexing",
			"\t\tfn.resize(this->n, 0);//fill it with IDENTITY element",
			"\t}",
			"",
			"\t//THE UPDATE FUNCTION",
			"\tvoid add(int x, int y) {",
			"\t\t//O(logn) at most",
			"\t\tx++; // 1 based index",
			"\t\twhile (x < n) {",
			"\t\t\tfn[x] += y;",
			"\t\t\t//we add the last set bit (going down in the tree)",
			"\t\t\tx += (x & (-x));// last set bit",
			"\t\t}",
			"\t}",
			"",
			"\t//THE QUERY FUNCTION",
			"\tint sum(int x) {",
			"\t\t//O(logn) at most",
			"\t\tx++; // 1 based index",
			"\t\tint ans = 0;//IDENTITY element",
			"\t\twhile (x) {",
			"\t\t\tans += fn[x];",
			"\t\t\t//we delete the last set bit (going up in the tree)",
			"\t\t\tx -= (x & (-x));//last set bit",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\t//THE QUERY FUNCTION",
			"\tint sum(int l, int r) {",
			"\t\t//calulate the sum from l to r(0 based indexing)",
			"\t\t//O(logn) at most",
			"\t\treturn sum(r) - sum(l - 1);",
			"\t}",
			"",
			"};"],
			"description": "it is like segment tree but more efficient in terms of space and time, but it has limitations.You can code it verys fast"
		
	},
	"Sqrt decomposition":{
		"prefix": "sqrtDecomposition",
		"body": [
			"//sqrt decomposition for the range sum query",
			"struct sqrtDecompostion {",
			"\t//sqrt decomposition is used to perform range queries in O(sqrt(n)) time complexity",
			"\t//use segment tree or fenwick tree if you want to perform range queries",
			"\t//this is used for Mo's algorithm",
			"\tvector<int> blocks;",
			"\tvector<int> arr;",
			"\tint n;",
			"\tint len;",
			"\tsqrtDecompostion(vector<int> arr) {",
			"\t\t//O(n) time complexity",
			"\t\tn = arr.size();",
			"\t\tlen = sqrt(n) + 1;//at most sqrt(n) + 1 blocks",
			"\t\tblocks.assign(len, 0);//initially all blocks are 0 (NETURAL ELEMENT OF OPERATION)",
			"\t\tfor (int i = 0;i < n;i++) {",
			"\t\t\t//each block will have sqrt(n) elements and will contain SUM of those elements",
			"\t\t\tblocks[i / len] += arr[i];",
			"\t\t}",
			"\t\tthis->arr = arr;",
			"",
			"\t}",
			"\tvoid update(int idx, int val) {",
			"\t\t//O(1) time complexity (if we use prefix sum array then it will take O(n) time complexity)",
			"\t\t//Replace the value at idx with val",
			"\t\tint blockNumber = idx / len;",
			"\t\tblocks[blockNumber] += val - arr[idx];",
			"\t}",
			"\tint query(int l, int r) {",
			"\t\t//O(sqrt(n)) time complexity",
			"\t\t//There will be at most 2 blocks which are partially included in the range",
			"\t\t//O(sqrt(n)) + O(2*sqrt(n)) = O(sqrt(n))",
			"\t\t//O(sqrt(n)) -> for completely included blocks",
			"\t\t//O(2*sqrt(n)) -> for the two  partially included blocks",
			"\t\tint sum = 0;//NETURAL ELEMENT OF OPERATION",
			"\t\tfor (int i = l;i <= r;) {",
			"\t\t\tif (i % len == 0 && i + len - 1 <= r) {",
			"\t\t\t\t//if i is starting of a block and the block is completely inside the range",
			"\t\t\t\tsum += blocks[i / len];",
			"\t\t\t\ti += len;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\t//else add elemnt",
			"\t\t\t\tsum += arr[i];",
			"\t\t\t\ti++;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"};"
		],
		"description": "it is used to perform range queries in O(sqrt(n)) time complexity"
	},
	"Mo's algorithm":{
		"prefix": "MoAlgorithm",
		"body": [
			"// Mo's algorithm is a technique to process offline queries in O( (n+q) * sqrt(n)) time",
			"// offline queries means that we have all the queries before hand and we want to process them all at once",
			"// online queries means that we have to process each query as soon as we get it",
			"",
			"// Structure for the query",
			"struct Query {",
			"    int l, r, ans, block, id;",
			"    bool operator<(const Query& other) const {",
			"        return make_pair(block, r) < make_pair(other.block, other.r);",
			"    }",
			"};",
			"",
			"// Global variables",
			"int N = 1e6;",
			"vector<Query> queries;",
			"vector<int> cnt(N, 0);",
			"int distinct = 0;",
			"",
			"// Add val to the answer",
			"void add(int val) {",
			"    if (cnt[val] == 0) distinct++; // The answer goes from 0 to 1, so the element is now present",
			"    cnt[val]++;",
			"}",
			"",
			"// Remove val from the answer",
			"void remove(int val) {",
			"    cnt[val]--;",
			"    if (cnt[val] == 0) distinct--; // The answer goes from 1 to 0, so the element is no longer present",
			"}",
			"",
			"// Mo's algorithm",
			"void MoAlgorithm(vector<int> a, vector<pair<int, int>> q) {",
			"    // O( (n+q) * sqrt(n))",
			"    // q: number of queries, n: size of the array (explained below)",
			"    // a: the actual array",
			"    // q: the queries",
			"    int lengthOfBlock = sqrt(a.size()); // sqrt decomposition",
			"    queries.resize(q.size());",
			"    for (int i = 0; i < q.size(); i++) {",
			"        queries[i].l = q[i].first;",
			"        queries[i].r = q[i].second;",
			"        queries[i].block = queries[i].l / lengthOfBlock;",
			"        queries[i].id = i;",
			"    }",
			"    // Sorting the queries based on the block first and then the right index",
			"    // The query with the lesser block will be processed first",
			"    // The query with the same block and lesser right index will be processed first",
			"    sort(queries.begin(), queries.end());",
			"",
			"    int x = 0, y = 0; // 2 pointers",
			"",
			"    for (int i = 0; i < queries.size(); i++) {",
			"        int l = queries[i].l, r = queries[i].r;",
			"        // Our goal here is to make x = l and y = r+1 (because x is inclusive and y is exclusive)",
			"        while (x < l) {",
			"            remove(a[x]);",
			"            x++;",
			"        }",
			"        while (x > l) {",
			"            x--;",
			"            add(a[x]);",
			"        }",
			"        while (y <= r) {",
			"            add(a[y]);",
			"            y++;",
			"        }",
			"        while (y > r + 1) {",
			"            y--;",
			"            remove(a[y]);",
			"        }",
			"        queries[i].ans = distinct; // Calculate the answer",
			"    }",
			"",
			"    // Sorting the queries based on the id",
			"    sort(queries.begin(), queries.end(), [](Query a, Query b) {",
			"        return a.id < b.id;",
			"    });",
			"",
			"    // Printing the answer",
			"    for (int i = 0; i < queries.size(); i++) {",
			"        cout << queries[i].l << \"->\" << queries[i].r << \" \" << queries[i].ans << endl;",
			"    }",
			"}"
		],
		"description": "Mo's algorithm is a technique to process offline queries in O( (n+q) * sqrt(n)) time"

	},
	//GRAPH
	"Graph structure":{
		"prefix": ["graph","graphStructure","dfs","bfs","shortestPath"],
		"body": [
			"class Graph {",
			"",
			"    // DFS and BFS in O(V + E) time",
			"    // O(V + E) : V = number of vertices, E = number of edges",
			"    // complexity is O(V + E) because",
			"    // we do vis[node] = true only when we push it in the queue which is done only once for each node so --> V",
			"    // we check the value of vis[node] for every child of the node so --> 2 * E (in the worst case,directed graph)",
			"",
			"public:",
			"    int n;",
			"    vector<vector<int>> adj;",
			"    Graph(int n) {",
			"        this->n = n;",
			"        adj.resize(n);",
			"    }",
			"    void addEdge(int u, int v, bool bidir = true) {",
			"        // 0 based indexing",
			"        // O(1)",
			"        // we suppose that the the graph is undirected by default, you can change it by passing false in the third argument",
			"        adj[u].push_back(v);",
			"        if (bidir) adj[v].push_back(u);",
			"    }",
			"    void bfs(int src) {",
			"        // O(V + E)",
			"        vector<bool> vis(n, false);",
			"        queue<int> q;",
			"        q.push(src);",
			"        vis[src] = true;// mark the source node as visited (pushed in the queue)",
			"        while (!q.empty()) {",
			"            int node = q.front();",
			"            q.pop();",
			"            cout << node << \" \";",
			"            for (auto child : adj[node]) {",
			"                if (!vis[child]) {",
			"                    q.push(child);",
			"                    vis[child] = true;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfs(int src, vector<bool>& vis) {",
			"        // O(V + E) ",
			"        vis[src] = true;",
			"        cout << src << \" \";",
			"        for (auto child : adj[src]) {",
			"            if (!vis[child]) {",
			"                dfs(child, vis);",
			"            }",
			"        }",
			"    }",
			"    void dfs(int src) {",
			"        // O(V + E)",
			"        vector<bool> vis(n, false);",
			"        dfs(src, vis);",
			"    }",
			"    void print() {",
			"        for (int i = 0;i < n;i++) {",
			"            cout << i << \" -> \";",
			"            for (auto child : adj[i]) {",
			"                cout << child << \" \";",
			"            }",
			"            cout << \"\\n\";",
			"        }",
			"    }",
			"    void shortest_path(int src) {",
			"        //for every node print the minimum distance from the source node",
			"        //BFS",
			"        //O(V + E)",
			"        //works only in unweighted graphs",
			"        //the first time a node is visited is the shortest path to that node",
			"        //the dist[child] = dist[parent] + 1",
			"        vector<int> dist(n, -1);",
			"        queue<int> q;",
			"        q.push(src);",
			"        dist[src] = 0;",
			"        while (!q.empty()) {",
			"            int parent = q.front();",
			"            q.pop();",
			"            for (auto child : adj[parent]) {",
			"                if (dist[child] == -1) {",
			"                    q.push(child);",
			"                    dist[child] = dist[parent] + 1;",
			"                }",
			"            }",
			"        }",
			"        for (int i = 0;i < n;i++) {",
			"            cout << \"Distance from \" << src << \" to \" << i << \" is \" << dist[i] << \"\\n\";",
			"        }",
			"",
			"    }",
			"    void shortest_path(int src, int dest) {",
			"        //print the shortest path from src to dest",
			"        //BFS",
			"        //O(V + E)",
			"        //works only in unweighted graphs",
			"        //the first time a node is visited is the shortest path to that node",
			"        //the dist[child] = dist[parent] + 1",
			"        vector<int> dis(n, -1);",
			"        queue<int> q;",
			"        vector<int> parent(n, -1);",
			"        q.push(src);",
			"        dis[src] = 0;",
			"        while (!q.empty()) {",
			"            int p = q.front();",
			"            if (p == dest) break;",
			"            q.pop();",
			"            for (auto child : adj[p]) {",
			"                if (dis[child] == -1) {",
			"                    q.push(child);",
			"                    dis[child] = dis[p] + 1;",
			"                    parent[child] = p;",
			"                }",
			"            }",
			"        }",
			"",
			"        int temp = dest;",
			"        while (temp != -1) {",
			"            cout << temp << \" \";",
			"            temp = parent[temp];",
			"        }",
			"",
			"",
			"    }",
			"};"
		],
		"description": "Graph structure with DFS, BFS and shortest path algorithms"

	},
	"Graph structure with node":{
		"prefix": ["graph","graphNode","graphNodeStructure","dfs","bfs","shortestPath"],
		"body": [
			"class Node {",
			"public:",
			"    string name;",
			"    vector<Node*> children;",
			"    Node(string name) {",
			"        this->name = name;",
			"    }",
			"    Node() {}",
			"};",
			"",
			"class Graph {",
			"",
			"    // You should definetely use node* and not node because",
			"    // (it can work with node(add default constructor)) but it is not recommended)",
			"   // 1- It is easier to manipulate pointers than objects, you can pass them by reference and change them",
			"   // 2- You can use unordered_map<Node*, bool> vis instead of unordered_map<string, bool> vis because node* is unique and string is not",
			"   // 3- It is better for memory management",
			"",
			"",
			"",
			"// IMPORTANT",
			"//  when working with node ,use unordered_map<Node*,type of value you want to store>",
			"//  ex:",
			"//  unordered_map<Node*, bool> vis;",
			"//     unordered_map<Node*, int> dist;",
			"//     unordered_map<Node*, Node*> parent;",
			"",
			"public:",
			"    unordered_map<string, Node*> mp;",
			"    Graph(vector<string> cities) {",
			"        for (auto city : cities) {",
			"            mp[city] = new Node(city);",
			"        }",
			"    }",
			"    void addEdge(string u, string v, bool bidir = true) {",
			"        mp[u]->children.push_back(mp[v]);",
			"        if (bidir) mp[v]->children.push_back(mp[u]);",
			"    }",
			"    void print() {",
			"        for (auto node : mp) {",
			"            cout << node.first << \" -> \";",
			"            for (auto child : node.second->children) {",
			"                cout << child->name << \" \";",
			"            }",
			"            cout << \"\\n\";",
			"        }",
			"    }",
			"    void bfs(string src) {",
			"        // O(V + E)",
			"        queue<Node*> q;",
			"        unordered_map<Node*, bool> vis;",
			"        q.push(mp[src]);",
			"        vis[mp[src]] = true;",
			"        while (!q.empty()) {",
			"            Node* node = q.front();",
			"            q.pop();",
			"            cout << node->name << \" \";",
			"            for (auto child : node->children) {",
			"                if (!vis[child]) {",
			"                    q.push(child);",
			"                    vis[child] = true;",
			"                }",
			"            }",
			"        }",
			"    }",
			"    void dfs(string src) {",
			"        // O(V + E)",
			"        unordered_map<Node*, bool> vis;",
			"        dfs(mp[src], vis);",
			"    }",
			"    void dfs(Node* src, unordered_map<Node*, bool>& vis) {",
			"        // O(V + E)",
			"        vis[src] = true;",
			"        cout << src->name << \" \";",
			"        for (auto child : src->children) {",
			"            if (!vis[child]) {",
			"                dfs(child, vis);",
			"            }",
			"        }",
			"    }",
			"    void shortest_path(string src) {",
			"        //for every node print the minimum distance from the source node",
			"        // O(V + E)",
			"        unordered_map<Node*, bool> vis;",
			"        unordered_map<Node*, int> dist;",
			"        queue<Node*> q;",
			"        q.push(mp[src]);",
			"        vis[mp[src]] = true;",
			"        dist[mp[src]] = 0;",
			"        while (!q.empty()) {",
			"            Node* node = q.front();",
			"            q.pop();",
			"            for (auto child : node->children) {",
			"                if (!vis[child]) {",
			"                    q.push(child);",
			"                    vis[child] = true;",
			"                    dist[child] = dist[node] + 1;",
			"",
			"                }",
			"            }",
			"        }",
			"        for (auto node : dist) {",
			"            cout << node.first->name << \" \" << node.second << \"\\n\";",
			"        }",
			"    }",
			"    void shortest_path(string src, string dest) {",
			"        //print the shortest path from src to dest",
			"        // O(V + E)",
			"        unordered_map<Node*, bool> vis;",
			"        unordered_map<Node*, int> dist;",
			"        unordered_map<Node*, Node*> parent;",
			"        queue<Node*> q;",
			"        q.push(mp[src]);",
			"        vis[mp[src]] = true;",
			"        dist[mp[src]] = 0;",
			"        while (!q.empty()) {",
			"            Node* node = q.front();",
			"            q.pop();",
			"            for (auto child : node->children) {",
			"                if (!vis[child]) {",
			"                    q.push(child);",
			"                    vis[child] = true;",
			"                    dist[child] = dist[node] + 1;",
			"                    parent[child] = node;",
			"                }",
			"            }",
			"        }",
			"        while (dest != src) {",
			"            cout << dest << \" \";",
			"            dest = parent[mp[dest]]->name;",
			"        }",
			"        cout << src << \"\\n\";",
			"    }",
			"};"
		],
		"description": "Graph Node structure with DFS, BFS and shortest path algorithms"

	},
	"Tree structure":{
		"prefix": ["tree","treeStructure","dfs","bfs","shortestPath"],
		"body": [
			"class Tree {",
			"",
			"    // DFS and BFS are in O(V + E) time",
			"    // in tree v = n and e = n - 1 so complexity is O(n)",
			"    // we don't need to use visited array in dfs or bfs ",
			"    // we use the fact that every node in a tree has only one parent except the root node",
			"    // so we check if the node in the adjacency list is not the parent of the current node",
			"public:",
			"    int n;",
			"    vector<vector<int>> adj;",
			"    Tree(int n) {",
			"        this->n = n;",
			"        adj.resize(n);",
			"    }",
			"    void addEdge(int u, int v, bool bidir = true) {",
			"        // 0 based indexing",
			"        // O(1)",
			"        // we suppose that the the tree is undirected by default, you can change it by passing false in the third argument",
			"        adj[u].push_back(v);",
			"        if (bidir) adj[v].push_back(u);",
			"    }",
			"    void bfs(int src) {",
			"        // O(n)",
			"",
			"        queue<pair<int, int>> q;// {node,parent}",
			"        q.push({ src,-1 });// -1 is the parent of the root node",
			"        while (!q.empty()) {",
			"            auto p = q.front();",
			"            q.pop();",
			"            int node = p.first;",
			"            int parent = p.second;",
			"            cout << node << \" \";",
			"            for (auto child : adj[node]) {",
			"                if (child != parent) {",
			"                    q.push({ child,node });",
			"                }",
			"            }",
			"        }",
			"",
			"    }",
			"    void dfs(int src, int parent) {",
			"        // O(n)",
			"        cout << src << \" \";",
			"        for (auto child : adj[src]) {",
			"            if (child != parent) {",
			"                dfs(child, src);",
			"            }",
			"        }",
			"    }",
			"    void dfs(int src) {",
			"        // O(n)",
			"        dfs(src, -1);",
			"    }",
			"",
			"    void shortestPath(int src) {",
			"        //for every node print the minimum (there is only one path) from the source node",
			"        //BFS",
			"        //O(n)",
			"        //works only in unweighted graphs",
			"        //the first time a node is visited is the shortest path to that node",
			"        //the dist[child] = dist[parent] + 1",
			"        vector<int> dist(n, -1);//like the visited array",
			"        queue<int> q;",
			"        q.push(src);",
			"        dist[src] = 0;",
			"        while (!q.empty()) {",
			"            int parent = q.front();",
			"            q.pop();",
			"            for (auto child : adj[parent]) {",
			"                if (dist[child] == -1) {",
			"                    q.push(child);",
			"                    dist[child] = dist[parent] + 1;",
			"                }",
			"            }",
			"        }",
			"        for (int i = 0;i < n;i++) {",
			"            cout << \"Distance from \" << src << \" to \" << i << \" is \" << dist[i] << \"\\n\";",
			"        }",
			"    }",
			"    void shortest_path(int src, int dest) {",
			"        //print the shortest path (there is only path) from src to dest",
			"        //BFS",
			"        //O(n)",
			"        //works only in unweighted graphs",
			"        //the first time a node is visited is the shortest path to that node",
			"        //the dist[child] = dist[parent] + 1",
			"        vector<int> dis(n, -1);",
			"        queue<int> q;",
			"        vector<int> parent(n, -1);",
			"        q.push(src);",
			"        dis[src] = 0;",
			"        while (!q.empty()) {",
			"            int p = q.front();",
			"            if (p == dest) break;",
			"            q.pop();",
			"            for (auto child : adj[p]) {",
			"                if (dis[child] == -1) {",
			"                    q.push(child);",
			"                    dis[child] = dis[p] + 1;",
			"                    parent[child] = p;",
			"                }",
			"            }",
			"        }",
			"",
			"        int temp = dest;",
			"        while (temp != -1) {",
			"            cout << temp << \" \";",
			"            temp = parent[temp];",
			"        }",
			"",
			"",
			"    }",
			"};"
		],
		"description": "Tree structure with DFS, BFS and shortest path algorithms"
	},
	"DFS and backedges":{
		"prefix": ["dfsAndBackedges","backedges"],
		"body": [
			"const int N = 1e5 + 1;",
			"vector<int> graph[N];",
			"vector<int> vis(N, 0);",
			"bool cycle = false;",
			"void dfs_and_backedges(int src, int parent) {",
			"    // Print all the backedges and used to check if a graph has a cycle or not",
			"    vis[src] = 1;",
			"    for (auto child : graph[src]) {",
			"        if (vis[child] == 0) {",
			"            dfs_and_backedges(child, src);",
			"        }",
			"        else if (vis[child] == 1 && child != parent) {",
			"            cout << \"Backedge found between \" << src << \" and \" << child << \"\\n\";",
			"            cycle = true;",
			"        }",
			"    }",
			"}"
		],
		"description": "Print all the backedges and used to check if a graph has a cycle or not"
	},
	"Lowest common ancestor":{
		"prefix": ["lca","lowestCommonAncestor","lengthFromUtoV"],
		"body": [
			"const int N = 1e5 + 5;",
			"const int M = 20;//log2(N)",
			"vector<int> gr[N];",
			"int depth[N];",
			"int parent[N][M];//parent[i][j] is 2^j th parent of i",
			"",
			"void dfs(int cur, int par) {",
			"    //O(nlogn) time complexity",
			"    //1-based indexing",
			"    //precompute the parents",
			"    parent[cur][0] = par;",
			"    for (int i = 1;i < M;i++) {",
			"        parent[cur][i] = parent[parent[cur][i - 1]][i - 1];//2^i th parent of cur is 2^(i-1)th parent of 2^(i-1)th parent of cur",
			"    }",
			"",
			"    for (auto x : gr[cur]) {",
			"        if (x != par) {",
			"            depth[x] = depth[cur] + 1;",
			"            dfs(x, cur);",
			"        }",
			"    }",
			"}",
			"",
			"int lca(int u, int v) {",
			"    //O(logn) time complexity",
			"    //1-based indexing",
			"    if (depth[u] < depth[v]) {",
			"        swap(u, v);",
			"    }",
			"    int diff = depth[u] - depth[v];",
			"    //make both at same depth using binary lifting in O(log diff ) time",
			"    for (int i = M - 1;i >= 0;i--) {",
			"        if (diff & (1 << i)) {",
			"            u = parent[u][i];",
			"        }",
			"    }",
			"    //now both are at same depth",
			"    if (u == v)return u;",
			"    for (int i = M - 1;i >= 0;i--) {",
			"        if ( parent[u][i] != parent[v][i]) {",
			"            u = parent[u][i];",
			"            v = parent[v][i];",
			"        }",
			"    }",
			"    return parent[u][0];",
			"}",
			"",
			"int LengthFromUtoV(int u, int v) {",
			"    //O(logn) time complexity",
			"    //1-based indexing",
			"    return depth[u] + depth[v] - 2 * depth[lca(u, v)];",
			"    //we should subtract 2*depth[lca(u,v)] because we counted the depth of lca(u,v) twice",
			"}",
		],
		"description": "Lowest common ancestor using binary lifting",
	},
	"Topological sort":{
		"prefix": ["topologicalSort","topological","topoSort","topologicalOrder"],
		"body": [
			"// topological sort is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering.",
			"// it is like ordering tasks in the right order",
			"// topological sort is only possible in DAG(directed acyclic graph)",
			"",
			"const int N = 1e5 + 1;",
			"vector<int> graph[N];",
			"vector<int> vis(N, 0);",
			"vector<int> topOrder;",
			"int n,m;",
			"",
			"void dfs(int curr) {",
			"    vis[curr] = 1;",
			"    for (auto x : graph[curr]) {",
			"        if (!vis[x]) {",
			"            dfs(x);",
			"        }",
			"    }",
			"    //after visiting all the children of curr node(those nodes which are dependent on curr node),we can push curr node in topOrder",
			"    //after we will reverse the topOrder vector to get the correct answer",
			"    //finish time:time where we leave the node in dfs",
			"    topOrder.push_back(curr);",
			"}",
			"",
			"void toplogicalSort() {",
			"    //The topological order will be on topOrder",
			"    //1-based indexing",
			"    //O(V+E)",
			"    //works only for DAG(Directed Acyclic Graph)",
			"    //it won't throw error if graph is not DAG but it will not give correct answer",
			"    for (int i = 1; i <= n; i++) {",
			"        //if the node is not visited then we will call dfs on that node",
			"        //if it is not visited that means that node is not dependent on any other node that has been visited",
			"        //and some of the nodes that are dependent on that node has been visited",
			"        if (!vis[i]) {",
			"            dfs(i);",
			"        }",
			"    }",
			"    reverse(topOrder.begin(), topOrder.end());",
			"    for (auto x : topOrder) {",
			"        cout << x << \" \";",
			"    }",
			"}",
			

		],
		"description": "Topological sort using dfs for Directed Acyclic Graph",
	},
	"Kosaraju Algorithm":{
		"prefix": ["kosaraju","kosarajuAlgorithm","stronglyConnectedComponents","scc"],
		"body": [
			"const int N = 1e5 + 1;",
			"vector<int> graph[N], revGraph[N];",
			"int vis[N];",
			"vector<int> topOrder;",
			"int n,m;",
			"",
			"vector<int> component[N];",
			"int comp = 0;",
			"vector <int> belongToComp(N);",
			"",
			"void dfs_top(int curr) {",
			"    vis[curr] = 1;",
			"    for (auto x : graph[curr]) {",
			"        if (!vis[x]) {",
			"            dfs_top(x);",
			"        }",
			"    }",
			"    topOrder.push_back(curr);",
			"}",
			"",
			"void toplogicalSort() {",

			"    for (int i = 1; i <= n; i++) {",
			"        if (!vis[i]) {",
			"            dfs_top(i);",
			"        }",
			"    }",
			"    reverse(topOrder.begin(), topOrder.end());",
			"}",
			"",
			"void dfs_comp(int curr,int comp) {",
			"    belongToComp[curr] = comp + 1;//the current node belongs to comp component",
			"    component[comp+1].push_back(curr);//pushing the current node in the comp component",
			"    vis[curr] = 1;",
			"    for (auto x : revGraph[curr]) {",
			"        if (!vis[x]) {",
			"            dfs_comp(x,comp);",
			"        }",
			"    }",
			"}",
			"",
			"void determine_components() {",
			"    //Kosaraju's Algorithm:used to find  strongly connected components in a graph",
			"    //1-based indexing",
			"    //O(V+E)",
			"    //When reading the graph, we read the edges in reverse order and store them in a reverse graph.",
			"    toplogicalSort();",
			"    memset(vis, 0, sizeof(vis));",
			"    for (int i = 1; i <= n; i++) {",
			"        int v = topOrder[i];",
			"        if (!vis[v]) {",
			"            dfs_comp(v,comp);",
			"            comp++;//each time we find a node that is not visited that means we have found a new component(if it was part of SSc it would have been visited)",
			"        }",
			"    }",
			"cout << \"The number of components are: \" << comp - 1 << endl;",
			"for (int i = 1; i < comp; i++) {",
			"   cout << \"Component \" << i << \" : \";",
			"   for (auto x : component[i]) {",
			"       cout << x << \" \";",	
			"   }",
			"   cout << endl;",
			"}",
			"for (int i = 1; i <= n; i++) {",
			"   cout << \"Node \" << i << \" belongs to component \" << belongToComp[i] << endl;",
			"}",
			"}",
		],
		"description": "Kosaraju Algorithm: used to find strongly connected components in a graph",
	},
	"Disjoint Set Union Data Structure":{
		"prefix": ["dsu","disjointSetUnion","unionFind"],
		"body": [
			"class DSU {",
			"    //known as disjoint set union data structure or union find data structure",
			"    int* parent;",
			"    int* rank;",
			"public:",
			"    DSU(int n) {",
			"        parent = new int[n];",
			"        rank = new int[n];",
			"        //parent[i] = -1;",
			"        //rank[i] = 1;",
			"        for (int i = 0;i < n;i++) {",
			"            parent[i] = -1;",
			"            rank[i] = 1;",
			"        }",
			"    }",
			"    int findSet(int i) {",
			"        //return the root of the set in which element i is present",
			"        //O(height of tree)",
			"        //O(logV) as average ",
			"        //it can be O(V) in worst case (chain of V nodes)",
			"        if (parent[i] == -1) {",
			"            return i;",
			"        }",
			"        //path compression optimization:all nodes in path will point directly to parent",
			"        return parent[i] = findSet(parent[i]);",
			"    }",
			"    void union_set(int x, int y) {",
			"        //combine the sets in which x and y are present",
			"        //O(1): it needs a proof ",
			"        int s1 = findSet(x);",
			"        int s2 = findSet(y);",
			"        if (s1 != s2) {",
			"            //union by rank optimization:attach smaller rank tree under root of higher rank tree",
			"            //rank of set is number of nodes in that set",
			"            //we make that choice so that height of tree is minimized",
			"            if (rank[s1] < rank[s2]) {",
			"                parent[s1] = s2;",
			"                rank[s2] += rank[s1];",
			"            }",
			"            else {",
			"                parent[s2] = s1;",
			"                rank[s1] += rank[s2];",
			"            }",
			"        }",
			"    }",
			"};",
		],
		"description": "Disjoint Set Union Data Structure: used to find connected components in a UNIDRECTED graph",
	},

	"Cycle Detection in undirected graph":{
		"prefix": ["cycle","cycleDetection","detectCycle","cycleInUndirectedGraph"],
		"body": [
			"class Graph {",
			"    int V;",
			"    list<pair<int, int>> l;",
			"public:",
			"    Graph(int V) {",
			"        this->V = V;",
			"    }",
			"    void addEdge(int u, int v) {",
			"        l.push_back({ u,v });",
			"    }",
			"    int findSet(int i, int parent[]) {",
			"        //return the root of the set in which element i is present",
			"        //O(height of tree)",
			"        //O(logV) as average ",
			"        //it can be O(V) in worst case (chain of V nodes)",
			"        if (parent[i] == -1) {",
			"            return i;",
			"        }",
			"        //path compression optimization:all nodes in path will point directly to parent",
			"        return parent[i] = findSet(parent[i], parent);",
			"    }",
			"    bool union_set(int x, int y, int parent[], int rank[]) {",
			"        //combine the sets in which x and y are present",
			"        //return false if x and y are in same set",
			"        //O(1): it needs a proof ",
			"        int s1 = findSet(x, parent);",
			"        int s2 = findSet(y, parent);",
			"        if (s1 != s2) {",
			"            //union by rank optimization:attach smaller rank tree under root of higher rank tree",
			"            //rank of set is number of nodes in that set",
			"            //we make that choice so that height of tree is minimized",
			"            if (rank[s1] < rank[s2]) {",
			"                parent[s1] = s2;",
			"                rank[s2] += rank[s1];",
			"            }",
			"            else {",
			"                parent[s2] = s1;",
			"                rank[s1] += rank[s2];",
			"            }",
			"            return true;",
			"        }",
			"        return false;",
			"    }",
			"    bool contains_cycle() {",
			"        //DSU logic to check if UNDIRECTED  graph contains cycle or not",
			"        //O(Edges)",
			"        int* parent = new int[V];",
			"        int* rank = new int[V];",
			"        for (int i = 0;i < V;i++) {",
			"            parent[i] = -1;",
			"            rank[i] = 1;",
			"        }",
			"        for (auto edge : l) {",
			"            int i = edge.first;",
			"            int j = edge.second;",
			"            if (!union_set(i, j, parent, rank)) {",
			"                return true;",
			"            }",
			"        }",
			"        delete[] parent;",
			"        delete[] rank;",
			"        return false;",
			"    }",
			"};",
		],
		"description": "Cycle Detection in undirected graph using DSU",

	},
	"Minimum Spanning Tree using Prim's Algorithm":{
		"prefix":["prim","primMST","prim's","prim'sAlgorithm","MST","minimumSpanningTree","minimumSpanningTreeUsingPrim"],
		"body": [
			"class Graph {",
			"    int V;",
			"    list<pair<int, int>>* l;",
			"public:",
			"    Graph(int V) {",
			"        this->V = V;",
			"        l = new  list<pair<int, int>>[V + 1];",
			"    }",
			"",
			"    void addEdge(int u, int v, int w) {",
			"        l[u].push_back({ v,w });",
			"        l[v].push_back({ u,w });",
			"    }",
			"",
			"    int prim_mst() {",
			"        //It can bbe used to find the MST itself",
			"        //return the weight of the MST",
			"        //O(ElogV) => O(V^2logV) BE CAREFUL THIS CAN TAKE A LOT OF TIME TLE,CHECK THE CONSTRAINTS",
			"        //we use priority queue to get the edge with minimum weight (it uses heap internally)",
			"",
			"        //init a min heap",
			"        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> Q;",
			"        //visited array that denotes whether a node has been included in MST or not",
			"        bool* visited = new bool[V + 1] {false};",
			"        int ans = 0;",
			"        //begin",
			"        Q.push({ 0,1 }); //weight,node",
			"        while (!Q.empty()) {",
			"            //pick out the edge with min weight",
			"            auto best = Q.top();",
			"            Q.pop();",
			"            int to = best.second;",
			"            int weight = best.first;",
			"            if (visited[to]) {",
			"                //this is important as we may have same node with different weights in the queue",
			"                //discard the edge and continue",
			"                continue;",
			"            }",
			"            //otherwise take the current edge",
			"            ans += weight;",
			"            visited[to] = true;",
			"            //add the new edges in the queue",
			"            for (auto x : l[to]) {",
			"                if (visited[x.first] == false) {",
			"                    Q.push({ x.second,x.first });",
			"                }",
			"            }",
			"        }",
			"        return ans;",
			"",
			"    }",
			"};",
		],
		"description": "Minimum Spanning Tree using Prim's Algorithm",
	},
	"Minimum Spanning Tree using Kruksal's Algorithm (my preferred way)":{
		"prefix":["kruksal","kruksalAlgorithm","minimumSpanningTree","mst"],
		"body": [
		"class DSU {",
		"    int* parent;",
		"    int* rank;",
		"public:",
		"    DSU(int n) {",
		"        parent = new int[n];",
		"        rank = new int[n];",
		"        //parent[i] = -1;",
		"        //rank[i] = 1;",
		"        for (int i = 0;i < n;i++) {",
		"            parent[i] = -1;",
		"            rank[i] = 1;",
		"        }",
		"    }",
		"    //Find",
		"    int find(int i) {",
		"        //base case",
		"        if (parent[i] == -1) {",
		"            return i;",
		"        }",
		"        //otherwise",
		"        return parent[i] = find(parent[i]);",
		"    }",
		"    //Unite (union is a reserved keyword)",
		"    void unite(int x, int y) {",
		"        int s1 = find(x);",
		"        int s2 = find(y);",
		"        if (s1 != s2) {",
		"            //union by rank",
		"            if (rank[s1] < rank[s2]) {",
		"                parent[s1] = s2;",
		"                rank[s2] += rank[s1];",
		"            }",
		"            else {",
		"                parent[s2] = s1;",
		"                rank[s1] += rank[s2];",
		"            }",
		"        }",
		"    }",
		"};",
		"",
		"class Graph {",
		"    vector<vector<int>> edgelist;",
		"    int V;",
		"public:",
		"    Graph(int V) {",
		"        this->V = V;",
		"    }",
		"    void addEdge(int x, int y, int w) {",
		"        x--;",
		"        y--;",
		"        //we make 0 based indexing",
		"        edgelist.push_back({ w,x,y });",
		"    }",
		"    int kruksal_mst() {",
		"        //O(ElogV)",
		"        //With this algorithm it is easy to return the MST itself",
		"        //returns weight of MST",
		"        //Main Logic",
		"        //1. Sort all the edges based upon weight",
		"        sort(edgelist.begin(), edgelist.end());",
		"        //Init a DSU",
		"        DSU s(V);",
		"        int ans = 0;",
		"        for (auto edge : edgelist) {",
		"            int w = edge[0];",
		"            int x = edge[1];",
		"            int y = edge[2];",
		"            //Take that edge in MST if it doesn't form a cycle",
		"            if (s.find(x) != s.find(y)) {",
		"                s.unite(x, y);",
		"                ans += w;",
		"            }",
		"        }",
		"        return ans;",
		"    }",
		"};",
		],
		"description" : "minimum spanning tree using kruksal's algorithm"
	},
	"Shortest Path Djikestra":{
		"prefix": ["shortestPathDjikestra","dijkstra","shortestPath"],
		"body": [
			"class Graph {",
			"    int V;",
			"    list<pair<int, int>>* l;",
			"public:",
			"    Graph(int v) {",
			"        V = v;",
			"        l = new list<pair<int, int>>[V];",
			"    }",
			"    void addEdge(int u, int v, int wt, bool bidir = true) {",
			"        l[u].push_back({ v,wt });",
			"        if (bidir) {",
			"            l[v].push_back({ u,wt });",
			"        }",
			"    }",
			"    void printAdjList() {",
			"        for (int i = 0;i < V;i++) {",
			"            cout << i << \"->\";",
			"            for (auto node : l[i]) {",
			"                cout << \"(\" << node.first << \",\" << node.second << \")\";",
			"            }",
			"            cout << endl;",
			"        }",
			"    }",
			"    void dijkstra(int src) {",
			"        // Only works for +ve weighted graph",
			"        // returns the shortest distance of all the nodes from the src node",
			"        //O(ElogV)",
			"        // Data Structures",
			"        // 1. Set",
			"        set<pair<int, int>> s;//this set will contains the pair of distance and node",
			"        // 2. Distance array",
			"        vector<int> dist(V, INT_MAX);",
			"        // 3. Insert src node with distance = 0",
			"        dist[src] = 0;",
			"        s.insert({ 0,src });",
			"        while (!s.empty()) {",
			"            // Find the pair at the front",
			"            auto it = s.begin();",
			"            int node = it->second;",
			"            int distTillNow = it->first;",
			"            s.erase(it);",
			"            // Iterate over the neighbours of the current node",
			"            for (auto nbrPair : l[node]) {",
			"                int nbr = nbrPair.first;",
			"                int currentEdge = nbrPair.second;",
			"                if (distTillNow + currentEdge < dist[nbr]) {",
			"                    // In the set updation of a particular is not possible",
			"                    // we have to remove the old pair and insert the new pair to simulate updation",
			"                    auto f = s.find({ dist[nbr],nbr });",
			"                    if (f != s.end()) {",
			"                        s.erase(f);",
			"                    }",
			"                    // Insert the new pair",
			"                    dist[nbr] = distTillNow + currentEdge;",
			"                    s.insert({ dist[nbr],nbr });",
			"                }",
			"            }",
			"        }",
			"        // Print the distance array",
			"        for (int i = 0;i < V;i++) {",
			"            cout << \"Node \" << i << \" Dist from src \" << dist[i] << endl;",
			"        }",
			"    }",
			"};",


		],
		"description": "Shortest Path Djikestra used for weighted graph with positive edges,single source shortest path"

	},
	"Shortest Path Bellman Ford":{
		"prefix": ["bellmanFord","shortestPathBellmanFord","shortestPath"],
		"body": [
			"class Graph {",
			"    int V;",
			"    vector<vector<int>> edges;",
			"public:",
			"    Graph(int V) {",
			"        this->V = V;",
			"    }",
			"    void addEdge(int u, int v, int w) {",
			"        edges.push_back({ u, v, w });",
			"    }",
			"    void bellmanFord(int src) {",
			"        // O(VE) time complexity",
			"        // used for shortest path in a graph with negative edges",
			"        // can also be used to detect negative cycle",
			"        vector<int> dist(V, INT_MAX);",
			"        dist[src] = 0;",
			"        for (int i = 0; i < V - 1; i++) {",
			"            for (int j = 0; j < edges.size(); j++) {",
			"                int u = edges[j][0];",
			"                int v = edges[j][1];",
			"                int w = edges[j][2];",
			"                if (dist[u] <= INT_MAX - w && dist[u] + w < dist[v]) {",
			"",
			"                    //relaxation",
			"                    //we check if dist[u] is not INT_MAX - w because if it is then dist[u] + w will overflow",
			"                    //we suppose that INT_MAX is the maximum distance possible",
			"                    dist[v] = dist[u] + w;",
			"                }",
			"            }",
			"        }",
			"        for (int i = 0; i < edges.size(); i++) {",
			"            int u = edges[i][0];",
			"            int v = edges[i][1];",
			"            int w = edges[i][2];",
			"            if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {",
			"                cout << \"Negative cycle found\";",
			"                return;",
			"            }",
			"        }",
			"        for (int i = 0; i < V; i++) {",
			"            cout << i << \" \" << dist[i] << endl;",
			"        }",
			"    }",
			"};",

		],
		"description": "Shortest Path Bellman Ford used for weighted graph with negative edges,single source shortest path"
	},
	"Shortest Path Floyd Warshall":{
		"prefix": ["floydWarshall","shortestPathFloydWarshall","shortestPath"],
		"body": [
			"class Graph {",
			"    int V;",
			"    vector<vector<int>> adj;",
			"public:",
			"    Graph(int V) {",
			"        this->V = V;",
			"        adj.resize(V, vector<int>(V, INT_MAX));",
			"        for (int i = 0;i < V;i++) {",
			"            adj[i][i] = 0;",
			"        }",
			"    }",
			"    void addEdge(int u, int v, int w) {",
			"        adj[u][v] = w;",
			"    }",
			"    void floydWarshall() {",
			"        //O(V^3)",
			"        //all pair shortest path for directed graph (can be used for undirected graph also)",	
			"        //dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j])",
			"        //dp[i][j] = distance from i to j",
			"        //can be used to detect negative cycle",
			"        vector<vector<int>> dist(adj);",
			"        for (int k = 0;k < V;k++) {",
			"            for (int i = 0;i < V;i++) {",
			"                for (int j = 0;j < V;j++) {",
			"                    if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][k] + dist[k][j] < dist[i][j]) {",
			"                        //avoid a",
			"                        dist[i][j] = dist[i][k] + dist[k][j];",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        //detect negative cycle",
			"        for (int i = 0;i < V;i++) {",
			"            if (dist[i][i] < 0) {",
			"                cout << \"Negative cycle found\";",
			"                return;",
			"            }",
			"        }",
			"        for (int i = 0;i < V;i++) {",
			"            for (int j = 0;j < V;j++) {",
			"                cout << dist[i][j] << \" \";",
			"            }",
			"            cout << endl;",
			"        }",
			"",
			"",
			"    }",
			"",
			"};",
			"",
		],
		"description": "Shortest Path Floyd Warshall used for weighted directed graph with negative edges,all pair shortest path"
	},

	// OTHERS
	"Trie structure":{
		"prefix":["trie","trieStructure","trieNode"],
		"body": [
		"//example of a trie structure",
		"class TrieNode {",
		"public:",
		"\tchar s;",
		"\tunordered_map<char, TrieNode*> children;",
		"\tstring word;",
		"\tbool isTerminal;",
		"",
		"\tTrieNode(char s) {",
		"\t\tthis->s = s;",
		"\t\tisTerminal = false;",
		"\t\tword = \"\";",
		"\t}",
		"};",
		"",
		"class Trie {",
		"public:",
		"\tTrieNode* root;",
		"",
		"\tTrie() {",
		"\t\troot = new TrieNode('\\0');",
		"\t}",
		"",
		"\tvoid addWord(string word) {",
		"\t\t//O(word.size())",
		"\t\tTrieNode* temp = root;",
		"\t\tfor (auto ch : word) {",
		"\t\t\tif (temp->children.count(ch) == 0) {",
		"\t\t\t\ttemp->children[ch] = new TrieNode(ch);",
		"\t\t\t}",
		"\t\t\ttemp = temp->children[ch];",
		"\t\t}",
		"\t\t//last node",
		"\t\ttemp->isTerminal = true;",
		"\t\ttemp->word = word;",
		"\t}",
		"\tbool searchWord(string word) {",
		"\t\t//O(word.size())",
		"\t\tTrieNode* temp = root;",
		"\t\tfor (auto ch : word) {",
		"\t\t\tif (temp->children.count(ch) == 0) {",
		"\t\t\t\treturn false;",
		"\t\t\t}",
		"\t\t\ttemp = temp->children[ch];",
		"\t\t}",
		"\t\treturn temp->isTerminal;",
		"\t}",
		"};"],

		"description": "Trie is a type of k-ary search tree used for storing and searching a specific key from a set. Using Trie, search complexities can be brought to optimal limit (key length). ",
	},
	"Longest Increasing Subsequence":{
		"prefix":["LIS","longestIncreasingSubsequence"],
		"body": [
			"vector<int> v;",
			"",
			"bool compareIndexes(int i, int j) {",
			"\treturn v[i] < v[j];",
			"",
			"}",
			"",
			"vector<int> LIS() {",
			"\t//O(nlogn)",
			"\t//returns the longest increasing subsequence",
			"\t// dry run this example // v = { 1,6,7,6,6,6,6,7 };",
			"\tint n = v.size();",
			"\tvector<int> T(n, -1), R(n, -1);",
			"\tint length = 1;",
			"\tT[0] = 0;",
			"\tfor (int i = 1; i < n; i++) {",
			"\t\tif (v[i] < v[T[0]]) {",
			"\t\t\tT[0] = i;",
			"\t\t}",
			"\t\telse if (v[i] > v[T[length - 1]]) {//the subsequence is increasing strictly",
			"\t\t\t // else if(v[i] >= v[T[length - 1]]){//the subsequence is increasing non-strictly",
			"\t\t\tR[i] = T[length - 1];",
			"\t\t\tT[length++] = i;",
			"\t\t}",
			"\t\telse {",
			"\t\t\tint index = lower_bound(T.begin(), T.begin() + length, i, compareIndexes) - T.begin();//if the subsequence is increasing strictly",
			"\t\t\t// int index = upper_bound(T.begin(), T.begin() + length, i, compareIndexes) - T.begin();//if the subsequence is increasing non-strictly",
			"\t\t\tR[i] = T[index - 1];",
			"\t\t\tT[index] = i;",
			"\t\t}",
			"\t}",
			"\tvector<int> result;",
			"\tfor (int i = T[length - 1]; i >= 0; i = R[i]) {",
			"\t\tresult.push_back(v[i]);",
			"\t}",
			"\treverse(result.begin(), result.end());",
			"\treturn result;",
			"",
			"}"],
		"description": "O(nlogn) algorithm to find the longest increasing subsequence of a given sequence"
	},
	"findSubarraySum":{
		"prefix":["findNumberOfSubarrayEqualToSum","findSubarraySum","subarraySum"],
		"body": [
			"int findSubarraySum(vector<int> v, int sum) {",
			"\t//O(n)",
			"\t//returns the number of subarrays whose sum is equal to sum",
			"\tint n = v.size();",
			"\tint currSum = 0;",
			"\tint ans = 0;",
			"\tmap<int, int> prevSum;",
			"\tfor (int i = 0; i < n; i++) {",
			"\t\tcurrSum += v[i];",
			"\t\tif (currSum == sum) {",
			"\t\t\tans++;",
			"\t\t}",
			"\t\t\tans += prevSum[currSum - sum];",
			"\t\tprevSum[currSum]++;",
			"\t}",
			"\treturn ans;",
			"}"],
	}
}


