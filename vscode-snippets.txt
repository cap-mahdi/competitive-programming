{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body wiint be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",`
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Starting code with test cases":{
		"prefix":"solvewithtestcases",
		"body":[
			"#include <bits/stdc++.h>",
			"#define int long long int",
			"using namespace std;",
			"",
			"void solve(){",
			"\t$0",
			"}",
			"int32_t main(){",
			"    //fast I/O",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    int t;",
			"    cin >> t;",
			"    while(t--){",
			"        solve();",
			"    }",
			"    return 0;",
			"}",
		],
		"description": "Starting code with test cases"
	},
	"Starting code":{
		"prefix":"solve",
		"body":[
			"#include <bits/stdc++.h>",
			"#define int long long int",
			"using namespace std;",
			"",
			"void solve(){",
			"\t$0",
			"}",
			"int32_t main(){",
			"    //fast I/O",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"    solve();",
			"    return 0;",
			"}",
		],
		"description": "Starting code with test cases"
	},
	"Bits manipulation":{
		"prefix":"bitsManipulation",
		"body":[
			"//Bits Manipulation",
			"int getIthBit(int n, int i){",
				"\treturn (n & (1 << i)) != 0;",
			"}\n",
			
			"void setIthBit(int &n, int i){",
				"\tn = n | (1 << i);",
			"}\n",
			
			"void clearIthBit(int &n, int i){",
				"\tn = n & (~(1 << i));",
			"}\n",
			
			"void updateIthBit(int &n, int i, int v){",
				"\tclearIthBit(n, i);",
				"\tn = n | (v << i);",
			"}\n",
			
			"void clearLastIBits(int &n, int i){",
				"\tint mask = (-1 << i);",
				"\tn=  n & mask;",
			"}\n",
			
			"void clearRangeItoJ(int &n, int i, int j){",
				"\tint a = (-1 << (j + 1));",
				"\tint b = (1 << i) - 1;",
				"\tint mask = a | b;",
				"\tn = n & mask;",
			"}\n",

			"void replaceBits(int &n, int m, int i, int j){",
				"//replacee i to j bits of n with m",
				"\tclearRangeItoJ(n, i, j);",
				"\tn = n | (m << i);",
				"}",
				
				"int checkPowerOf2(int n){ ",
				"\treturn (n & (n - 1)) == 0;",
				"}",
				
				"int countSetBits(int n){",
					"//complexity: O(no. of set bits)",
				"\tint count = 0;",
				"\twhile(n){",
					"\t//remove last set bit",
					"\tn = n & (n - 1);",
					"\tcount++;",
				"}",
				"\treturn count;\n",
				"//     //complexity: O(logn + 1) ",
				"// int count = 0;",
				"// while(n){",
				"//     count += (n & 1);",
				"//     n = n >> 1;",
				"// }",
				"// return count;",
				"}\n",
				
				"long long convertToBinary(int n){",
					"\tlong long ans = 0;",
					"\tlong long p = 1;",
					"\twhile(n){",
						"\tans += (n & 1) * p;",
						"\tp *= 10;",
						"\tn = n >> 1;",
					"}",
					"\treturn ans;",
				"}\n",
		],
		"description": "Bits manipulation"
	},
	"Big integer manipulation":{
		"prefix":"bigIntegerManipulation",
		"body":[
		"//Big Integer Manipulation",
		"void swap(string &a,string &b){",
			"\tstring temp = a;",
			"\ta = b;",
			"\tb = temp;",
		"}\n",
		
		"string addBigIntegers(string a,string b){",
			"\tif(a.length() > b.length())",
				"\tswap(a,b);",
			
			"\tstring result = \"\";",
		
			"\treverse(a.begin(),a.end());",
			"\treverse(b.begin(),b.end());",
		
			"\tint carry = 0;",
			"\tfor(int i = 0; i<a.length();i++){",
				"\tint sum = (a[i] - '0') + (b[i] - '0') + carry;",
				"\tresult.push_back(sum%10 + '0');",
				"\tcarry = sum/10;",
			"}",
		
			"\tfor(int i = a.length();i<b.length();i++){",
				"\tint sum = (b[i] - '0') + carry;",
				"\tresult.push_back(sum%10 + '0');",
				"\tcarry = sum/10;",
			"\t}",
		
			"\tif(carry)",
				"\tresult.push_back('1');",
			
			"\treverse(result.begin(),result.end());",
		
			"\treturn result;",
		"}\n",
		
		"string multiply(string a,int b){",
			"\tstring result = \"\";",
			"\tint carry = 0;",
			"\tfor(int i=a.length()-1;i>=0;i--){",
				"\tint product = (a[i] - '0') * b + carry;",
				"\tresult.push_back(product%10 + '0');",
				"\tcarry = product/10;",
			"}",
			"\twhile(carry){",
				"\tresult.push_back(carry%10 + '0');",
				"\tcarry = carry/10;",
			"\t}",
			"\treverse(result.begin(),result.end());",
			"\treturn result;",
		"}\n",
		
		"string bigFactorial(int n){",
			"\tstring result = \"1\";",
			"\tfor(int i=2;i<=n;i++){",
				"\tresult = multiply(result,i);",
			"\t}",
			"\treturn result;",
		"}",
	
	],
		"description": "Big integer manipulation"
	},
	"Matrix":{
		"prefix":"matrix",
		"body":[
			"class Mat {",
				"public:",
					"\tint n, m;",
					"\tvector<vector<int>> mat;",
					"\tMat(int n, int m){",
						"\t\tthis->n = n;",
						"\t\tthis->m = m;",
						"\t\tmat.resize(n, vector<int>(m, 0));",
					"\t}",
					
					"\tvoid identity(){",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tmat[i][i] = 1;",
						"\t\t}",
					"\t}\n",

					"\tvoid print(){",
						"\t\tcout<<\"Matrix \"<<n<<\" * \"<<m<<\"\\n\";",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tfor(int j = 0; j < m; j++){",
								"\t\t\t\tcout << mat[i][j] << \" \";",
							"\t\t\t}",
							"\t\t\tcout << \"\\n\";",
						"\t\t}",
					"\t}\n",

					"\tMat operator*(const Mat &other){",
						"\t\tMat res(n, other.m);",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tfor(int j = 0; j < other.m; j++){",
								"\t\t\t\tfor(int k = 0; k < m; k++){",
									"\t\t\t\t\tres.mat[i][j] += mat[i][k] * other.mat[k][j];",
								"\t\t\t\t}",
							"\t\t\t}",
						"\t\t}",
						"\t\treturn res;",
					"\t}\n",

					"\tMat operator^(int b){",
						"\t\tMat res(n, m);",
						"\t\tres.identity();",
						"\t\tMat a = *this;",
						"\t\twhile(b > 0){",
							"\t\t\tif(b & 1) res = res * a;",
							"\t\t\ta = a * a;",
							"\t\t\tb >>= 1;",
						"\t\t}",
						"\t\treturn res;",
					"\t}\n",

					"\tMat operator+(const Mat &other){",
						"\t\tMat res(n, m);",
						"\t\tfor(int i = 0; i < n; i++){",
							"\t\t\tfor(int j = 0; j < m; j++){",
								"\t\t\t\tres.mat[i][j] = mat[i][j] + other.mat[i][j];",
							"\t\t\t}",
						"\t\t}",
						"\t\treturn res;",
					"\t}",
				"};",
		],
		"description": "Matrix"
	},
	"binaryExponentiation":{
		"prefix":["binaryExponentiation","linearRecurrence"],
		"body":[
			"int binpow(int a, int b) {",
				"\tint res = 1;",
				"\twhile (b > 0) {",
					"\t\tif (b & 1) res *= a;",
					"\t\ta *= a;",
					"\t\tb >>= 1;",
				"\t}",
				"\treturn res;",
			"}\n",
			"const int MOD = 1e9 + 7;\n",
			"long long int binpowwithmod(long long int a, long long int b){",
				"\tlong long int res = 1;",
				"\twhile(b > 0){",
					"\t\tif(b & 1) res = (res * a) % MOD;",
					"\t\ta = (a * a) % MOD;",
					"\t\tb >>= 1;",
				"\t}",
				"\treturn res;",
			"}\n",
			"long long int binmultiplywithmod(long long int a,long long int b,long long int c){",
				"\tlong long int res = 0;",
				"\twhile(b){",
					"\t\tif(b & 1) res = (res + a) % c;",
					"\t\ta = (a*2) % c;",
					"\t\tb >>= 1;",
				"\t}",
				"\treturn res;",
			"}\n",
			"//Linear Recurrence\n",
			"//Fibonnaci\n",
			"//import Matrix!!!!!!!!!!!!!!!\n",
			"int Fibonnaci(int n){",
				"\tMat a(2, 2);",
				"\ta.mat[0][0] = 1;",
				"\ta.mat[0][1] = 1;",
				"\ta.mat[1][0] = 1;",
				"\tn-=2;",
				"\ta = a^n;",
				"\treturn a.mat[0][0] + a.mat[0][1];",
			"}\n",
		],
		"description": "Binary Exponentiation"
	},
	"inputArray":{
		"prefix":"inputArray",
		"body":[
			"for(int i = 0; i < ${1:arraySize}; i++){",
				"\tcin >> ${2:arrayName}[i];",
			"}",
		],
		"description": "Input array"
	},
	"Fibonnaci":{
		"prefix":"Fibonnaci",
		"body":[
			"int Fibonnaci(int n){",
				"\tMat a(2, 2);",
				"\ta.mat[0][0] = 1;",
				"\ta.mat[0][1] = 1;",
				"\ta.mat[1][0] = 1;",
				"\tn-=2;",
				"\ta = a^n;",
				"\treturn a.mat[0][0] + a.mat[0][1];",
			"}",
		],
		"description": "nth Fibonnaci"
	},
	"prime isPrime and primeFactorisation":{
		"prefix":["prime","isPrime","primeFactorisation"],
		"body":[
			"// determine if a number is prime",
			"// complexity: O(sqrt(n))",
			"// used if you have to check if a number is prime or not for a single time",
			"bool isPrime(int n){",
				"\tif(n==1){",
					"\t\treturn false;",
				"\t}",
				"\tif(n==2){",
					"\t\treturn true;",
				"\t}",
				"\tif(n%2==0){",
					"\t\treturn false;",
				"\t}",
				"\tfor(int i=3;i*i<=n;i+=2){",
					"\t\tif(n%i==0){",
						"\t\t\treturn false;",
					"\t\t}",
				"\t}",
				"\treturn true;",
			"}\n",

			"// factorise a number into its prime factors",
			"// complexity: O(sqrt(n))",
			"// used if you have to factorise a number for a single time",
			"void factoriseOpt(int n){",
				"\tfor(int i=2;i*i<=n;i++){",
					"\t\tif(n%i==0){",
						"\t\t\tint count =0;",
						"\t\t\twhile(n%i == 0){",
							"\t\t\t\tcount++;",
							"\t\t\t\tn/=i;",
						"\t\t\t}",
						"\t\t\tcout<<i<<\"^\"<<count<<\",\";",
					"\t\t}",
				"\t}",
				"\tif(n!=1){",
					"\t\t cout<<n<<\"^\"<<1;",
				"\t}",
				"\tcout<<\"\\n\";",
			"}",
		],
		"description": "isPrime function + factorisin a prime"
	},
	"primeSieve":{
		"prefix":["primeSieve","primeSieveFactorisation","sieve","factoriseSieve"],
		"body":[
			"// determine if a number is prime",
			"// complexity: O(sqrt(n))",
			"// used if you have to check if a number is prime or not for multiple times (test cases)",
			"// precomputation: O(nloglogn)",
			"// space complexity: O(n)",
			"void primeSieve(vector<int> &sieve){",
				"\tsieve[2]=1; ",
				"\tfor(int i=3;i<=N;i+=2){",
					"\t\tsieve[i]=1;",
				"\t}",
				"\tfor(int i=3; i<=N;i++){",
					"\t\tif(sieve[i]){",
						"\t\t\t",
						"\t\t\tfor(int j=i*i;j<=N;j+=i){",
							"\t\t\t\tsieve[j]=0;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
			"\n",
			"// factorise a number into its prime factors",
			"// used if you have to factorise a number for multiple times (test cases)",
			"// precomputation: O(nloglogn)",
			"// the factorisation of a number can be done in O(logn) time",
			"// space complexity: O(n)",
			"vector<int> sieve(N+1,0);",
			"\n",
			"void primeSieveFactorisation(){",
				"\tfor(int i=2;i<=N;i+=2){",
					"\t\tsieve[i]=2;",
				"\t}",
				"\tfor(int i=3;i<=N;i++){",
					"\t\tif(sieve[i]==0){",
						"\t\t\tsieve[i]=i;",
						"\t\t\tfor(int j=i*i;j<=N;j+=i){",
							"\t\t\t\tif(sieve[j]==0)",
								"\t\t\t\t\tsieve[j]=i;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
			"\n",
			"void factoriseSieve(int n){",
				"\twhile(n!=1){",
					"\t\tint count =0;",
					"\t\tint prime = sieve[n];",
					"\t\twhile(n%prime == 0 ){",
						"\t\t\tcount++;",
						"\t\t\tn/=prime;",
					"\t\t}",
					"\t\tcout<<prime<<\"^\"<<count<<\",\";",
				"\t}",
			"}",

		],
		"description": "sieve of eratosthenes + factorising a number into its prime factors for testcases + deterline if a number is prime or not for testcases"
	},
	"segmentedSieve":{
		"prefix":["segmentedSieve"],
		"body":[
			"// segmented sieve",
			"// used to find prime numbers in a range [m,n] ",
			"// complexity: O(nloglogn + (n-m+1)*sqrt(n))",
			"// space complexity: O(sqrt(n))",
			"vector<int> sieve(N+1,0);",
			"vector<int> primes;",
			"void primeSieve(){",
				"\tsieve[2]=1; ",
				"\tprimes.push_back(2);",
				"\n",
				"\tfor(int i=3;i<=N;i+=2){",
					"\t\tsieve[i]=1;",
				"\t}",
				"\tfor(int i=3; i<=N;i++){",
					"\t\tif(sieve[i]){",
						"\t\t\tprimes.push_back(i);",
						"\t\t\tfor(int j=i*i;j<=N;j+=i){",
							"\t\t\t\tsieve[j]=0;",
						"\t\t\t}",
					"\t\t}",
				"\t}",
			"}",
			"\n",
			"\n",
			"void segmentedSieve(){",
				"\tint n,m;",
				"\tcin>>m>>n;",
				"\n",
				"\tvector<int>segment(n-m+1,0);",
				"\n",
				"\tfor(int p : primes){",
					"\t\tif(p*p>n){",
						"\t\t\tbreak;",
					"\t\t}",
					"\n",
					"\t\tint start =  (m/p) * p ;",
					"\n",
					"\t\tif(p>=m){",
						"\t\t\tstart = 2*p;",
					"\t\t}",
					"\t\tfor(int j=start;j<=n;j = j + p){",
						"\t\t\tif(j<m){",
							"\t\t\t\tcontinue;",
						"\t\t\t}",
						"\t\t\tsegment[j-m]=1;",
					"\t\t}",
					"\n",
					"\t\t",
				"\t}",
				"\tfor(int j=m;j<=n;j++){",
						"\t\tif(segment[j-m]==0){",
							"\t\t\tcout<<j<<\"\\n\";",
						"\t\t}",
					"\t}",
					"\tcout<<\"\\n\";",
			"}",
		],
		"description": "segmented sieve + used to find prime numbers in a range to avoid TLE or memory limit exceeded"
	},
	"euclid gcd and lcm":{
		"prefix":["euclid","gcd","lcm"],
		"body":[
			"// determine the gcd of two numbers in O(log(min(a,b))) complexity",
			"int gcd(int a,int b){",
				"\tif(b==0){",
					"\t\treturn a;",
				"\t}",
				"\treturn gcd(b,a%b);",
			"}",
			"//determine the lcm of two numbers in O(log(min(a,b))) complexity",
			"int lcm(int a,int b){",
				"\treturn (a*b)/gcd(a,b);",
			"}",
		],
		"description": "euclid's algorithm to determine gcd and lcm of two numbers"
	},
	"extended euclid for modular multiplicative inverse":{
		"prefix":["extended","euclid","modulatMultiplicativeInverse","MMI","extendedEuclid","extendedGCD"],
		"body":[
			"//return the {x,y,gcd} such that ax + by = gcd(a,b), it uses the extended euclidean algorithm, is is done in O(log(min(a,b))) complexity",
			"vector<int> extendedGCD(int a,int b){",
				"\tif(b==0){",
					"\t\treturn {1,0,a};",
				"\t}",
				"\tvector <int> result = extendedGCD(b,a%b);",
				"\tint x1 = result[0];",
				"\tint y1 = result[1];",
				"\tint gcd = result[2];",
				"\treturn {y1, x1 - (a/b)*y1,gcd};",
				"\t",
			"}",
			"// print the modular multiplicative inverse of a modulo m if it exists, it uses the extended euclidean algorithm, is is done in O(log(min(a,b))) complexity",
			"//it finds x such that ax = 1 (mod m) if a and m are coprime",
			"void MMI(int a,int m){",
			"\t /! if m is prime then we can use fermat's little theorem to find the multiplicative modulo inverse of a modulo m call the snippet ModuloArithmetic.cpp",
				"\tvector<int> result = extendedGCD(a,m);",
				"\tint x = result[0];",
				"\tint gcd = result[2];",
				"\tif(gcd!=1){",
					"\t\tcout<<\"Multiplicative modulo inverse does not exist\"<<\"\\n\";",
				"\t}",
				"\telse{",
					"\t\tint ans = (x%m + m)%m;//to make sure that ans is in the range [0,b-1]",
					"\t\tcout<<\"Multiplicative modulo inverse is \"<<ans<<\"\\n\";",
				"\t}",
			"}",
		],
		"description": "extended euclid's algorithm to determine modular multiplicative inverse of a modulo m"
	},
	"extended linear diophantine equation": {
		"prefix": ["linear", "diophantine", "equation", "solutionForLinearDiophantine"],
		"body": [
			"// Return the {x, y, gcd} such that ax + by = gcd(a, b)",
			"// It uses the extended Euclidean algorithm and has a complexity of O(log(min(a, b)))",
			"vector<int> extendedGCD(int a, int b) {",
			"\tif (b == 0) {",
			"\t\treturn {1, 0, a};",
			"\t}",
			"\tvector<int> result = extendedGCD(b, a % b);",
			"\tint x1 = result[0];",
			"\tint y1 = result[1];",
			"\tint gcd = result[2];",
			"\treturn {y1, x1 - (a / b) * y1, gcd};",
			"}",
			"",
			"// Print the integral solution of ax + by = c if it exists",
			"// It uses the extended Euclidean algorithm and has a complexity of O(log(min(a, b)))",
			"void solutionForLinearDiophantine(int a, int b, int c) {",
			"\tvector<int> result = extendedGCD(a, b);",
			"\tint x0 = result[0];",
			"\tint y0 = result[1];",
			"\tint gcd = result[2];",
			"",
			"\tif (c % gcd) {",
			"\t\tcout << \"There is no solution\" << \"\\n\";",
			"\t\treturn;",
			"\t}",
			"",
			"\tint k = c / gcd;",
			"\tint a1 = a / gcd;",
			"\tint b1 = b / gcd;",
			"\tx0 = ((x0 * c) % b1 + b1) % b1;",
			"\ty0 = ((y0 * c) % a1 + a1) % a1;",
			"\tcout << \"x = \" << x0 << \" + k*\" << b1 << \"\\n\";",
			"\tcout << \"y = \" << y0 << \" - k*\" << a1 << \"\\n\";",
			"}"
		],
		"description": "Solving a linear Diophantine equation using the extended Euclidean algorithm"
	},
	"modulo arithmatic": {
		"prefix": ["ModuloArithmatic","modulo", "addmod", "submod", "multiplymod", "powermod", "modInverse", "divideMod", "calculateFactorialMod", "nCr", "nPr","combination","permutation"],
		"body": [
			"const int P = 1e9 + 7 ;//it shoud be prime number because we are using fermat's little theorem whichi is only applicable for prime numbers",
			"//the theoreme is : a^(p-1) = 1 (mod p) where p is prime number and a is any number so  we can write a^(p-2) = a^(-1) (mod p) which is the inverse of a",
			"const int N = 1e5 ;",
			"int fact[N];",
			"",
			"int addmod(int a, int b){",
			"\treturn (a + b) % P;",
			"}",
			"",
			"int submod(int a, int b){",
			"\treturn (a - b + P) % P;// to make sure the remainder is in the range [0, P-1]",
			"}",
			"",
			"int multiplymod(int a, int b){",
			"\treturn (a * b) % P;//a and b must be long long int because at worst case a*b can be 1e18 which cannot be stored in int",
			"}",
			"",
			"int powermod(int a, int b){",
			"\t//it determines a^b (mod p)",
			"\t//fast exponentiation in O(log(b))",
			"\tint res = 1;",
			"\twhile(b){",
			"\t\tif(b & 1){",
			"\t\t\tres = multiplymod(res, a);",
			"\t\t}",
			"\t\ta = multiplymod(a, a);",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"int modInverse(int a){",
			"\t//it determines  a^(-1) (mod p)",
			"\t///O(log(P ))",
			"\t//using fermat's little theorem",
			"\treturn powermod(a, P - 2);",
			"}",
			"",
			"int divideMod(int a, int b){",
			"\t// it determines a/b (mod p)",
			"\t//O(log(P ))",
			"\t//a/b = a * (b^(-1)) (mod p) = a * (b^(p-2)) (mod p)",
			"\treturn multiplymod(a, modInverse(b));",
			"}",
			"",
			"int calculateFactorialMod(){",
			"\t// it determines the factorial of all numbers from 0 to N (mod p)",
			"\t//O(N) ",
			"\tfact[0] = 1;",
			"\tfor(int i = 1; i <= N; i++){",
			"\t\tfact[i] = multiplymod(fact[i - 1], i);",
			"\t}",
			"}",
			"",
			"int nCr(int n, int r){",
			"\t//it determines nCr (mod p)",
			"\t//O(log(P ))",
			"\t//nCr = n! / (r! * (n - r)!)",
			"\t//nCr = n! * (r! * (n - r)!)^(-1) (mod p)",
			"\t//nCr = n! * (r! * (n - r)!)^(p - 2) (mod p)",
			"\tint numerator = fact[n];",
			"\tint denominator = multiplymod(fact[r], fact[n - r]);",
			"\treturn multiplymod(numerator, modInverse(denominator));",
			"}",
			"",
			"int nPr(int n, int r){",
			"\t//it determines nPr (mod p)",
			"\t//O(log(P ))",
			"\t//nPr = n! / (n - r)! because nPr = n * (n - 1) * (n - 2) * ... * (n - r + 1)",
			"\t//nPr = n! * (n - r)!^(-1) (mod p)",
			"\t//nPr = n! * (n - r)!^(p - 2) (mod p)",
			"\tint numerator = fact[n];",
			"\tint denominator = fact[n - r];",
			"\treturn multiplymod(numerator, modInverse(denominator));",
			"}"
		],
		"description": "modular arithmatic for addition, subtraction, multiplication, power, inverse, division, factorial, nCr, nPr"
	},
	"Chinese remainder theorem":{
		"prefix": ["ChineseRemainderTheorem", "chineseRemainder", "CRT"],
		"body": [
			"int multiplymod(int a, int b){",
			"\treturn (a * b) % mod ;//a and b must be long long int because at worst case a*b can be 1e18 which cannot be stored in int",
			"}",
			"",
			"int powermod(int a, int b){",
			"\t//fast exponentiation in O(log(b))",
			"\tint res = 1;",
			"\twhile(b){",
			"\t\tif(b & 1){",
			"\t\t\tres = multiplymod(res, a);",
			"\t\t}",
			"\t\ta = multiplymod(a, a);",
			"\t\tb >>= 1;",
			"\t}",
			"\treturn res;",
			"}",
			"",
			"int modInverse(int a, int p){",
			"\t///O(log(P))",
			"\t// if P is prime then you can directly find the modulo inverse of a using fermat's little theorem",
			"\t//using fermat's little theorem",
			"\treturn powermod(a, p-2);",
			"}",
			"void ChineseRemainderTheorem(int * primes ,int * remainders,int n){",
			"\tint N = 1;",
			"\tfor(int i = 0; i < n; i++){",
			"\t\tN *= primes[i];",
			"\t}",
			"\tint result = 0;",
			"\tfor(int i = 0; i < n; i++){",
			"\t\tint Ni = (N / primes[i]);",
			"\t\tint x = multiplymod(remainders[i], modInverse(Ni % primes[i], primes[i]));",
			"\t\tresult += multiplymod(x, Ni);",
			"\t}",
			"\tcout << result % N << \" + k*\" << N  << \"\\n\";",
			"",
			"}"
		],
		"description": "Chinese remainder theorem, finding the smallest positive value of x such that x % p[i] = r[i] for all i such that p[i] and p[j] are coprime for all i != j"
	},
	"Euler's Totient Function":{
		"prefix": ["EulerTotientFunction", "EulerTotient", "EulerPhi","count_numbers_with_gcd","countNumbersWithGCD","count_numbers_less_than_n_with_gcd"],
		"body": [
			"const int N = 1e6+5;",
			"",
			"int phi[N];",
			"void calcul_totient(){",
			"\t//calculating phi for all numbers from 1 to N",
			"\t//Complexity: O(NloglogN)",
			"\tiota(phi,phi+N,0);",
			"\tfor(int i=2;i<N;i++){",
			"\t\tif(phi[i]==i){",
			"\t\t\tfor(int j=i;j<N;j+=i){",
			"\t\t\t\tphi[j] -= phi[j]/i;",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"}",
			"",
			"int count_numbers_less_than_n_with_gcd(int n,int g){",
			"\tif(n%g!=0) return 0;",
			"\treturn phi[n/g];",
			"}"
		],
		"description": "Euler's Totient Function, it is used to find the number of numbers from 1 to n which are coprime with n, it is also used to find the number of numbers from 1 to n such that gcd(i,n) = g"
	},
	"Binomial Coefficient":{
		"prefix": ["BinomialCoefficient", "binomialCoefficient", "nCr", "nCrDP", "nCrDynamicProgramming"],
		"body": [
			"const int N = 1e5;",
			"vector<vector<int>> binomialCoefficients(N+1, vector<int>(1,0));",
			"//nCk = binomialCoefficients[n][k]",
			"//used if you need nCk or binomialCoefficients[n][k] for multiple queries",
			"void computeBinomialCoefficients(){",
			"\t//O(n^2)",
			"\tfor(int i=0; i<=N; i++){",
			"\t\tbinomialCoefficients[i][0] = 1;",
			"\t\tfor(int j=1; j<i; j++){",
			"\t\t\tbinomialCoefficients[i].push_back(binomialCoefficients[i-1][j-1] + binomialCoefficients[i-1][j]);",
			"\t\t}",
			"\t\tbinomialCoefficients[i].push_back(1);",
			"\t}",
			"}",
			"",
			"int nCr(int n,int k){",
			"\t return binomialCoefficients[n][k];",
			"}",
			"const int P = 1e9 + 7;",
			"int fact[N];",
			"int multiplymod(int a, int b){",
			"\treturn (a * b) % P;//a and b must be long long int because at worst case a*b can be 1e18 which cannot be stored in int",
			"}",
			"int calculateFactorialMod(){",
			"\t//O(N) ",
			"\tfact[0] = 1;",
			"\tfor(int i = 1; i <= N; i++){",
			"\t\tfact[i] = multiplymod(fact[i - 1], i);",
			"\t}",
			"}",
			"int nPr(int n,int k){",
			"\treturn binomialCoefficients[n][k]*fact[k];",
			"}"

		],
			"description": "Binomial Coefficient, it is used to find the value of nCr, it can be computed using dynamic programming in O(n^2) time and O(n^2) space"
	},
	"Generating subsets and permutation using BackTracking and recursion":{
		"prefix": ["subsets", "permutations", "subsetsRecursion", "permutationsRecursion", "subsetsBackTracking", "permutationsBackTracking","BackTracking"],
		"body": [
			"// generating all subsets of a string using recursion in O(2^n)" ,
			"//the call will be subsets(s,\"\",0,s.size())",
			"void subsets(string s,string output,int i,int n){",
			"\t//base case",
			"\tif(i==n){",
			"\t\tcout<<output<<\"\\n\";",
			"\t\treturn;",
			"\t}",
			"",
			"\t//recursive case",
			"\tsubsets(s,output,i+1,n);",
			"\toutput.push_back(s[i]);",
			"\tsubsets(s,output,i+1,n);",
			"}",
			"",
			"// generating all permutations of a string using recursion in O(n * n!)",
			"//the call will be permutations(s,0,s.size())",
			"void permutations(string s,int i,int n){",
			"\t//base case",
			"\tif(i==n){",
			"\t\tcout<<s<<\"\\n\";",
			"\t\treturn;",
			"\t}",
			"",
			"\t//recursive case",
			"\tfor(int j=i;j<n;j++){",
			"\t\tswap(s[i],s[j]);",
			"\t\tpermutations(s,i+1,n);",
			"\t\tswap(s[i],s[j]);",
			"\t}",
			"}"
		],
		"description": "Generating subsets and permutation using BackTracking"
	},
	"Binary Search":{
		"prefix": ["binarySearch", "lowerBound", "upperBound", "occurence","occurrenceInSortedArray","lowerBoundInSortedArray","upperBoundInSortedArray"],
		"body": [
			"int binarySearch(vector<int> v,int key){",
			"\t//find the index of the key in the sorted array",
			"\t//O(logn)",
			"\tint n = v.size();",
			"\tint start = 0;",
			"\tint end = n-1;",
			"\twhile(start<=end){",
			"\t\tint mid = (start+end)/2;",
			"\t\tif(v[mid]==key){",
			"\t\t\treturn mid;",
			"\t\t}",
			"\t\telse if(v[mid]>key){",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t}",
			"\treturn -1;",
			"}",
			"",
			"int lowerBound(vector<int> v,int key){",
			"\t//lower bound is the first index where the key is present in a sorted array",
			"\t//O(logn)",
			"\tint n = v.size();",
			"\tint start = 0;",
			"\tint end = n-1;",
			"\tint ans = -1;",
			"\twhile(start<=end){",
			"\t\tint mid = (start+end)/2;",
			"\t\tif(v[mid]==key){",
			"\t\t\tans = mid;",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse if(v[mid]>key){",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"int upperBound(vector<int> v,int key){",
			"\t//upper bound is the last index where the key is present in a sorted array",
			"\t// O(logn)",
			"\tint n = v.size();",
			"\tint start = 0;",
			"\tint end = n-1;",
			"\tint ans = -1;",
			"\twhile(start<=end){",
			"\t\tint mid = (start+end)/2;",
			"\t\tif(v[mid]==key){",
			"\t\t\tans = mid;",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t\telse if(v[mid]>key){",
			"\t\t\tend = mid-1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\tstart = mid+1;",
			"\t\t}",
			"\t}",
			"\treturn ans;",
			"}",
			"",
			"int occurence(vector<int> v,int key){",
			"\t//find the number of occurences of the key in the sorted array",
			"\t//O(logn)  ",
			"\tint lower = lowerBound(v,key);",
			"\tint upper = upperBound(v,key);",
			"\tif(lower==-1) return 0;",
			"\treturn upper-lower+1;",
			"}"
		],
		"description": "binary search used to binary search, lower bound, upper bound and occurence of a key in a sorted array" 
	},
	"Merge Sort":{
		"prefix": ["mergeSort"],
		"body": [
			"void merge(vector<int> &arr,int s,int e){",
			"\t//O(n)",
			"\tvector<int> temp;",
			"\tint mid = (s + e) / 2;",
			"\tint i = s;",
			"\tint j = mid + 1;",
			"\twhile(i <= mid && j <= e){",
			"\t\tif(arr[i] < arr[j]){",
			"\t\t\ttemp.push_back(arr[i++]);",
			"\t\t}",
			"\t\telse{",
			"\t\t\ttemp.push_back(arr[j++]);",
			"\t\t}",
			"\t}",
			"",
			"\twhile(i <= mid){",
			"\t\ttemp.push_back(arr[i]);",
			"\t\ti++;",
			"\t}",
			"",
			"\twhile(j <= e){",
			"\t\ttemp.push_back(arr[j]);",
			"\t\tj++;",
			"\t}",
			"\t",
			"\tint k = 0;",
			"\tfor(int idx = s; idx <= e; idx++){",
			"\t\tarr[idx] = temp[k++];",
			"\t}",
			"",
			"}",
			"",
			"void mergeSort(vector<int> &arr,int s,int e){",
			"\t//sort the array in the range [s,e]",
			"\t//O(nlogn)",
			"\t//base case",
			"\tif(s >= e){",
			"\t\treturn;",
			"\t}",
			"",
			"\t//recursive case",
			"\t//divide",
			"\tint mid = (s + e) / 2;",
			"\tmergeSort(arr, s, mid);",
			"\tmergeSort(arr, mid + 1, e);",
			"\tmerge(arr, s, e);",
			"}"
		],
		"description": "Merge Sort is a divide and conquer algorithm. It divides input array in two halves, calls itself for the two halves and then merges the two sorted halves. The merge() function is used for merging two halves."
	},
	"Quick Sort":{
		"prefix": ["quickSort"],
		"body": [
			"int partition(vector<int> &arr, int s, int e){",
			"\t// O(n)",
			"\tint pivot = arr[e];",
			"\tint i = s - 1;",
			"\tfor (int j = s; j < e; j++){",
			"\t\tif (arr[j] < pivot){",
			"\t\t\ti++;",
			"\t\t\tswap(arr[i], arr[j]);",
			"\t\t}",
			"\t}",
			"\tswap(arr[i + 1], arr[e]);",
			"\treturn i + 1;",
			"}",
			"void quickSort(vector<int> &arr, int s, int e){",
			"\t//sort the array in the range [s,e]",
			"\t// O(nlogn) to O(n^2)",
			"\t// base case",
			"\tif (s >= e){",
			"\t\treturn;",
			"\t}",
			"",
			"\t// recursive case",
			"\t// divide",
			"\tint p = partition(arr, s, e); // return the index of the pivot element placed in the correct position",
			"\t// conquer",
			"\tquickSort(arr, s, p - 1);",
			"\tquickSort(arr, p + 1, e);",
			"}"
		],
		"description": "Quick Sort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot."
	},
	"quickSelect":{
		"prefix": "quickSelect",
		"body": [
			"//****quick select",
			"int partition(vector<int> &arr, int s, int e){",
			"\t//divide the array into two parts such that all the elements in the left part are smaller than the pivot element and all the elements in the right part are greater than the pivot element",
			"\t// O(n)",
			"\tint pivot = arr[e];",
			"\tint i = s - 1;",
			"\tfor (int j = s; j < e; j++){",
			"\t\tif (arr[j] < pivot){",
			"\t\t\ti++;",
			"\t\t\tswap(arr[i], arr[j]);",
			"\t\t}",
			"\t}",
			"\tswap(arr[i + 1], arr[e]);",
			"\treturn i + 1;",
			"}",
			"",
			"int quickSelect(vector<int> &arr, int s, int e, int k){",
			"\t//find the kth smallest element in the array",
			"\t// O(n) to O(n^2)",
			"\t// base case",
			"\tif (s >= e){",
			"\t\treturn -1;",
			"\t}",
			"",
			"\t// recursive case",
			"\tint p = partition(arr, s, e);",
			"\tif (p + 1 == k){",
			"\t\treturn arr[p];",
			"\t}",
			"\telse if (p > k){",
			"\t\treturn quickSelect(arr, s, p - 1, k);",
			"\t}",
			"\telse{",
			"\t\treturn quickSelect(arr, p + 1, e, k);",
			"\t}",
			"}"
		],
		"description": "Quick Select is a selection algorithm to find the kth smallest element in an unordered list. It is related to the quick sort sorting algorithm."
	},
	"Ternary search":{
		"prefix": "ternarySearch",
		"body": [
			"double ternarySeachForMin(double s, double e){",
			"\t// find the minimum of the parabola f THAT SHOULD BE DEFINED in the range [s,e]",
			"\t// O(log(3/2)n)",
			"\tdouble eps = 1e-6;",
			"\t// cout<< setprecision(10)<<fixed; if you fixed it to 10 decimal places you won't get 6 ",
			"\twhile (e - s > eps)",
			"\t{",
			"\t\t// cout << s << \" \" << e << \" \" << e-s << \" \" << (e-s)/3 << endl;",
			"\t\tdouble mid1 = s + (e - s) / 3;",
			"\t\tdouble mid2 = e - (e - s) / 3;",
			"\t\tif (parabola(mid1) < parabola(mid2))",
			"\t\t{",
			"\t\t\te = mid2;",
			"\t\t}",
			"\t\telse",
			"\t\t{",
			"\t\t\ts = mid1;",
			"\t\t}",
			"\t}",
			"\treturn s;",
			"}",
			"",
			"int ternarySeach(vector<int> arr, int s, int e){",
			"\t// find the maximum of the array in the range [s,e],this array should increase then decrease",
			"\t// O(log(3/2)n)",
			"\twhile(s <= e){",
			"\t\tint mid1 = s + (e - s) / 3;",
			"\t\tint mid2 = e - (e - s) / 3;",
			"\t\tif(arr[mid1] < arr[mid2]){",
			"\t\t\ts = mid1 + 1;",
			"\t\t}",
			"\t\telse{",
			"\t\t\te = mid2 - 1;",
			"\t\t}",
			"\t}",
			"\treturn arr[s];",
			"}"
		],
		"description": "Ternary search is a divide and conquer algorithm that can be used to find an element in an array. It is similar to binary search where we divide the array into two parts but in this algorithm, we divide the given array into three parts and determine which has the key (searched element)."
	},
	"Counting Sort":{
		"prefix": "countingSort",
		"body": [
			"void countingSort(int a[],int size, int m, int n){",
			"\t//sorting the array in O(N) time.",
			"\t//assuming the range of the elements in the array is [m,n]",
			"",
			"\tint freq[n-m+1] = {0};",
			"\t//frequency of each element in the array.",
			"\tfor(int i = 0;i<size;i++){",
			"\t\tfreq[a[i]-m]++;",
			"\t}",
			"",
			"\t//prefix sum array of freq",
			"\tfor(int i=1;i<=n-m;i++){",
			"\t\tfreq[i]+=freq[i-1];",
			"\t}",
			"",
			"\tint ans[size];",
			"\t//from the end of the array to maintain stability,we are using freq[a[i]-m]-1 as the index then decrementing freq[a[i]-m]",
			"\tfor(int i = size-1;i>=0;--i){",
			"\t\tans[freq[a[i]-m]-1] = a[i];",
			"\t\tfreq[a[i]-m]--;",
			"\t}",
			"",
			"\t//copying the sorted array to the original array.",
			"\tfor(int i = 0;i<size;i++){",
			"\t\ta[i] = ans[i];",
			"\t}",
			"",
			"}"
		],
		"description": "Counting sort is a sorting technique based on keys between a specific range. It works by counting the number of objects having distinct key values (kind of hashing). Then doing some arithmetic to calculate the position of each object in the output sequence."
	},
	"Count number of elements of sorted array in range":{
		"prefix": ["countNumberOfElementsInRange","countNumberOfElementsInSortedArrayInRange","countNumberOfElements"],
		"body": [
			"int count_number_of_elements_in_range(int a[], int N, int l, int r) {",
			"\t//returns the number of elements in the SORTED array whose value lies in the range [l,r]",
			"\t//O(logN)",
			"\treturn upper_bound(a, a + N, r) - lower_bound(a, a + N, l);",
			"}"
		],
		"description": "Count number of elements of sorted array in range [l, r]"
	},
	"Segment Tree":{
		"prefix": "segmentTree",
		"body": [
			"//example of segment tree for sum of range",
			"struct segmenttree {",
    		"//we use this structure in case we have an array and multiple queries and after each query we have to update an element of an array ",
			"\tint n;",
			"\tvector<int> st;",
			"",
			"\tvoid init(int _n) {",
			"\t\tthis->n = _n;",
			"\t\tst.resize(4 * n, 0);//TODO: fill it with IDENTITY ELEMENT(in this case it is 0 for sum)",
			"\t}",
			"",
			"\tvoid build(int start, int ending, int node, vector<int> &v) {",
			"\t\t// leaf node base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = v[start];",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\t// left subtree is (start,mid)",
			"\t\tbuild(start, mid, 2 * node + 1, v);",
			"",
			"\t\t// right subtree is (mid+1,ending)",
			"\t\tbuild(mid + 1, ending, 2 * node + 2, v);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the question (in this case it is sum)",
			"\t}",
			"",
			"\tint query(int start, int ending, int l, int r, int node) {",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn 0;//TODO: return the IDENTITY ELEMENT (in this case it is 0 for sum)",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\treturn st[node];",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tint q1 = query(start, mid, l, r, 2 * node + 1);",
			"\t\tint q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
			"",
			"\t\treturn q1 + q2;//TODO: change the operation according to the question (in this case it is sum)",
			"\t}",
			"",
			"\tvoid update(int start, int ending, int node, int index, int value) {",
			"\t\t// base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = value;",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"\t\tif (index <= mid) {",
			"\t\t\t// left subtree",
			"\t\t\tupdate(start, mid, 2 * node + 1, index, value);",
			"\t\t}",
			"\t\telse {",
			"\t\t\t// right",
			"\t\t\tupdate(mid + 1, ending, 2 * node + 2, index, value);",
			"\t\t}",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the question (in this case it is sum)",
			"",
			"\t\treturn;",
			"\t}",
			"",
			"\tvoid build(vector<int> &v) {",
			"\t\t// O(n)",
			"\t\tbuild(0, n - 1, 0, v);",
			"\t}",
			"",
			"\tint query(int l, int r) {",
			"\t\t// O(logn)",
			"\t\treturn query(0, n - 1, l, r, 0);",
			"\t}",
			"",
			"\tvoid update(int x, int y) {",
			"\t\t// O(logn)",
			"\t\tupdate(0, n - 1, 0, x, y);",
			"\t}",
			"};",
		],
		"description": "segment tree structure used if we have an array and multiple queries and after each query we have to update an element  of an array"
	},
	"Segment tree with lazy propagation":{
		"prefix": "segmentTreeWithLazyPropagation",
		"body": [
			"struct segmentTreeWithLazyPropagation {",
			"\t//we use this structure in case we have an array and multiple queries and after each query we have to update a range of array ",
			"\tint n;",
			"\tvector<int> st, lazy;",
			"",
			"\tvoid init(int _n) {",
			"\t\tthis->n = _n;",
			"\t\tst.resize(4 * n, 0);//TODO: fill the st with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\tlazy.resize(4 * n, 0);//TODO: fill the lazy with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t}",
			"",
			"\tvoid build(int start, int ending, int node, vector<int>& v) {",
			"\t\t// leaf node base case",
			"\t\tif (start == ending) {",
			"\t\t\tst[node] = v[start];",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\t// left subtree is (start,mid)",
			"\t\tbuild(start, mid, 2 * node + 1, v);",
			"",
			"\t\t// right subtree is (mid+1,ending)",
			"\t\tbuild(mid + 1, ending, 2 * node + 2, v);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the problem (in this case it is sum)",
			"\t}",
			"",
			"\tint query(int start, int ending, int l, int r, int node) {",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn 0;//TODO: return the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t}",
			"",
			"\t\t// lazy propagation / clear the lazy update",
			"\t\tif (lazy[node] != 0) {//TODO: compare with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t\t// pending updates",
			"\t\t\t// update the segment tree node",
			"\t\t\t//TODO: change the operation according to what he is doing in the range update (in this case it is adding same value to all the elements in the range)",
			"\t\t\tst[node] += lazy[node] * (ending - start + 1);//3andou dayn lzem ikahlsou que ce soit ken bech yetla3 houwa complete case wla 9bal mayebaath el wledou",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\t//TODO: change the operation according to the problem (in this case the lazy contains the value to be added to all the elements in the range)",
			"\t\t\t\tlazy[2 * node + 1] += lazy[node];",
			"\t\t\t\tlazy[2 * node + 2] += lazy[node];",
			"\t\t\t}",
			"\t\t\tlazy[node] = 0;//TODO: assign the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\treturn st[node];",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tint q1 = query(start, mid, l, r, 2 * node + 1);",
			"\t\tint q2 = query(mid + 1, ending, l, r, 2 * node + 2);",
			"",
			"\t\treturn q1 + q2;//TODO: change the operation according to the problem (in this case it is sum)",
			"\t}",
			"",
			"\tvoid update(int start, int ending, int node, int l, int r, int value) {",
			"\t\t// lazy propagation / clear the lazy update",
			"\t\tif (lazy[node] != 0) {//TODO: compare with the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t\t// pending updates",
			"\t\t\t// update the segment tree node",
			"\t\t\t//TODO: change the operation according to what he is doing in the range update (in this case it is adding same value to all the elements in the range)",
			"\t\t\tst[node] += lazy[node] * (ending - start + 1);//we can not do this in case of partial case be cause we will update this value at the end of the function",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\t//TODO: change the operation according to the problem (in this case the lazy contains the value to be added to all the elements in the range)",
			"\t\t\t\tlazy[2 * node + 1] += lazy[node];",
			"\t\t\t\tlazy[2 * node + 2] += lazy[node];",
			"\t\t\t}",
			"\t\t\tlazy[node] = 0;//TODO: assign the ELEMENT IDENTITY for the operation.(in this case it is 0 for the sum)",
			"\t\t}",
			"",
			"\t\t// non overlapping case",
			"\t\tif (start > r || ending < l) {",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\t// complete overlap",
			"\t\tif (start >= l && ending <= r) {",
			"\t\t\t// update the segment tree node",
			"\t\t\tst[node] += value * (ending - start + 1);//TODO: change the operation according to what he is doing in the range update (in this case it is adding same value to all the elements in the range)",
			"\t\t\tif (start != ending) {",
			"\t\t\t\t// propagate the updated value",
			"\t\t\t\t//TODO: change the operation according to the problem (in this case the lazy contains the value to be added to all the elements in the range)",
			"\t\t\t\tlazy[2 * node + 1] += value;",
			"\t\t\t\tlazy[2 * node + 2] += value;",
			"\t\t\t}",
			"\t\t\treturn;",
			"\t\t}",
			"",
			"\t\t// partial case",
			"\t\tint mid = (start + ending) / 2;",
			"",
			"\t\tupdate(start, mid, 2 * node + 1, l, r, value);",
			"\t\tupdate(mid + 1, ending, 2 * node + 2, l, r, value);",
			"",
			"\t\tst[node] = st[node * 2 + 1] + st[node * 2 + 2];//TODO: change the operation according to the problem (in this case it is sum)",
			"\t}",
			"",
			"\tvoid build(vector<int>& v){",
			"\t\t//O(n)",
			"\t\tbuild(0, n - 1, 0, v);",
			"\t}",
			"",
			"\tint query(int l, int r){",
			"\t\t//O(logn) ",
			"\t\treturn query(0, n - 1, l, r, 0);",
			"\t}",
			"",
			"\tvoid update(int l, int r, int value){",
			"\t\t//O(logn), it is know to close to query implementation not like the simple segment tree",
			"\t\tupdate(0, n - 1, 0, l, r, value);",
			"\t}",
			"};"],
			"description": "Segment Tree with Lazy Propagation used if we have an array and multiple queries and after each query we have to update a range of array",
	},
	"fenwick tree":{
		"prefix": ["fenwick","fenwickTree","binaryIndexedTree"],
		"body": [
			"//example of a fenwick tree for range sum queries",
			"struct fenwick {",
			"\t//It used like segment tree but it is more efficient in terms of space and time",
			"\t//it is also called binary indexed tree",
			"\t//It has limitations",
			"\t//It does not support range updates",
			"\t//Advantage: easy to understand and code (it takes only 10 lines of code)",
			"\tvector<int> fn;",
			"\tint n;",
			"",
			"\tvoid init(vector<int> v) {",
			"\t\tthis->n = v.size() + 1;//1 based indexing",
			"\t\tfn.resize(this->n, 0);//fill it with IDENTITY element",
			"\t\tfor (int i = 0; i < v.size(); i++) {",
			"\t\t\tthis->add(i, v[i]);",
			"\t\t}",
			"\t}",
			"",
			"\tvoid init(int n) {",
			"\t\tthis->n = n + 1;//1 based indexing",
			"\t\tfn.resize(this->n, 0);//fill it with IDENTITY element",
			"\t}",
			"",
			"\t//THE UPDATE FUNCTION",
			"\tvoid add(int x, int y) {",
			"\t\t//O(logn) at most",
			"\t\tx++; // 1 based index",
			"\t\twhile (x < n) {",
			"\t\t\tfn[x] += y;",
			"\t\t\t//we add the last set bit (going down in the tree)",
			"\t\t\tx += (x & (-x));// last set bit",
			"\t\t}",
			"\t}",
			"",
			"\t//THE QUERY FUNCTION",
			"\tint sum(int x) {",
			"\t\t//O(logn) at most",
			"\t\tx++; // 1 based index",
			"\t\tint ans = 0;//IDENTITY element",
			"\t\twhile (x) {",
			"\t\t\tans += fn[x];",
			"\t\t\t//we delete the last set bit (going up in the tree)",
			"\t\t\tx -= (x & (-x));//last set bit",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"",
			"\t//THE QUERY FUNCTION",
			"\tint sum(int l, int r) {",
			"\t\t//calulate the sum from l to r(0 based indexing)",
			"\t\t//O(logn) at most",
			"\t\treturn sum(r) - sum(l - 1);",
			"\t}",
			"",
			"};"],
			"description": "it is like segment tree but more efficient in terms of space and time, but it has limitations.You can code it verys fast"
		
	},
	"Sqrt decomposition":{
		"prefix": "sqrtDecomposition",
		"body": [
			"//sqrt decomposition for the range sum query",
			"struct sqrtDecompostion {",
			"\t//sqrt decomposition is used to perform range queries in O(sqrt(n)) time complexity",
			"\t//use segment tree or fenwick tree if you want to perform range queries",
			"\t//this is used for Mo's algorithm",
			"\tvector<int> blocks;",
			"\tvector<int> arr;",
			"\tint n;",
			"\tint len;",
			"\tsqrtDecompostion(vector<int> arr) {",
			"\t\t//O(n) time complexity",
			"\t\tn = arr.size();",
			"\t\tlen = sqrt(n) + 1;//at most sqrt(n) + 1 blocks",
			"\t\tblocks.assign(len, 0);//initially all blocks are 0 (NETURAL ELEMENT OF OPERATION)",
			"\t\tfor (int i = 0;i < n;i++) {",
			"\t\t\t//each block will have sqrt(n) elements and will contain SUM of those elements",
			"\t\t\tblocks[i / len] += arr[i];",
			"\t\t}",
			"\t\tthis->arr = arr;",
			"",
			"\t}",
			"\tvoid update(int idx, int val) {",
			"\t\t//O(1) time complexity (if we use prefix sum array then it will take O(n) time complexity)",
			"\t\t//Replace the value at idx with val",
			"\t\tint blockNumber = idx / len;",
			"\t\tblocks[blockNumber] += val - arr[idx];",
			"\t}",
			"\tint query(int l, int r) {",
			"\t\t//O(sqrt(n)) time complexity",
			"\t\t//There will be at most 2 blocks which are partially included in the range",
			"\t\t//O(sqrt(n)) + O(2*sqrt(n)) = O(sqrt(n))",
			"\t\t//O(sqrt(n)) -> for completely included blocks",
			"\t\t//O(2*sqrt(n)) -> for the two  partially included blocks",
			"\t\tint sum = 0;//NETURAL ELEMENT OF OPERATION",
			"\t\tfor (int i = l;i <= r;) {",
			"\t\t\tif (i % len == 0 && i + len - 1 <= r) {",
			"\t\t\t\t//if i is starting of a block and the block is completely inside the range",
			"\t\t\t\tsum += blocks[i / len];",
			"\t\t\t\ti += len;",
			"\t\t\t}",
			"\t\t\telse {",
			"\t\t\t\t//else add elemnt",
			"\t\t\t\tsum += arr[i];",
			"\t\t\t\ti++;",
			"\t\t\t}",
			"\t\t}",
			"\t\treturn sum;",
			"\t}",
			"};"
		],
		"description": "it is used to perform range queries in O(sqrt(n)) time complexity"
	},
	"Mo's algorithm":{
		"prefix": "MoAlgorithm",
		"body": [
			"// Mo's algorithm is a technique to process offline queries in O( (n+q) * sqrt(n)) time",
			"// offline queries means that we have all the queries before hand and we want to process them all at once",
			"// online queries means that we have to process each query as soon as we get it",
			"",
			"// Structure for the query",
			"struct Query {",
			"    int l, r, ans, block, id;",
			"    bool operator<(const Query& other) const {",
			"        return make_pair(block, r) < make_pair(other.block, other.r);",
			"    }",
			"};",
			"",
			"// Global variables",
			"int N = 1e6;",
			"vector<Query> queries;",
			"vector<int> cnt(N, 0);",
			"int distinct = 0;",
			"",
			"// Add val to the answer",
			"void add(int val) {",
			"    if (cnt[val] == 0) distinct++; // The answer goes from 0 to 1, so the element is now present",
			"    cnt[val]++;",
			"}",
			"",
			"// Remove val from the answer",
			"void remove(int val) {",
			"    cnt[val]--;",
			"    if (cnt[val] == 0) distinct--; // The answer goes from 1 to 0, so the element is no longer present",
			"}",
			"",
			"// Mo's algorithm",
			"void MoAlgorithm(vector<int> a, vector<pair<int, int>> q) {",
			"    // O( (n+q) * sqrt(n))",
			"    // q: number of queries, n: size of the array (explained below)",
			"    // a: the actual array",
			"    // q: the queries",
			"    int lengthOfBlock = sqrt(a.size()); // sqrt decomposition",
			"    queries.resize(q.size());",
			"    for (int i = 0; i < q.size(); i++) {",
			"        queries[i].l = q[i].first;",
			"        queries[i].r = q[i].second;",
			"        queries[i].block = queries[i].l / lengthOfBlock;",
			"        queries[i].id = i;",
			"    }",
			"    // Sorting the queries based on the block first and then the right index",
			"    // The query with the lesser block will be processed first",
			"    // The query with the same block and lesser right index will be processed first",
			"    sort(queries.begin(), queries.end());",
			"",
			"    int x = 0, y = 0; // 2 pointers",
			"",
			"    for (int i = 0; i < queries.size(); i++) {",
			"        int l = queries[i].l, r = queries[i].r;",
			"        // Our goal here is to make x = l and y = r+1 (because x is inclusive and y is exclusive)",
			"        while (x < l) {",
			"            remove(a[x]);",
			"            x++;",
			"        }",
			"        while (x > l) {",
			"            x--;",
			"            add(a[x]);",
			"        }",
			"        while (y <= r) {",
			"            add(a[y]);",
			"            y++;",
			"        }",
			"        while (y > r + 1) {",
			"            y--;",
			"            remove(a[y]);",
			"        }",
			"        queries[i].ans = distinct; // Calculate the answer",
			"    }",
			"",
			"    // Sorting the queries based on the id",
			"    sort(queries.begin(), queries.end(), [](Query a, Query b) {",
			"        return a.id < b.id;",
			"    });",
			"",
			"    // Printing the answer",
			"    for (int i = 0; i < queries.size(); i++) {",
			"        cout << queries[i].l << \"->\" << queries[i].r << \" \" << queries[i].ans << endl;",
			"    }",
			"}"
		],
		"description": "Mo's algorithm is a technique to process offline queries in O( (n+q) * sqrt(n)) time"

	},
	

			
	// OTHERS
	"Trie structure":{
		"prefix":["trie","trieStructure","trieNode"],
		"body": [
			"struct TrieNode {",
			"\tbool isEnd;",
			"\tTrieNode* children[26];",
			"};",
			"",
			"TrieNode* getNode() {",
			"\tTrieNode* node = new TrieNode;",
			"\tnode->isEnd = false;",
			"\tfor (int i = 0; i < 26; i++) {",
			"\t\tnode->children[i] = NULL;",
			"\t}",
			"\treturn node;",
			"}",
			"",
			"void insert(TrieNode* root, string key) {",
			"\t//O(key.size())",
			"\tTrieNode* temp = root;",
			"\tfor (int i = 0; i < key.size(); i++) {",
			"\t\tint index = key[i] - 'a';",
			"\t\tif (temp->children[index] == NULL) {",
			"\t\t\ttemp->children[index] = getNode();",
			"\t\t}",
			"\t\ttemp = temp->children[index];",
			"\t}",
			"\ttemp->isEnd = true;",
			"}",
			"",
			"bool search(TrieNode* root, string key) {",
			"\t//O(key.size())",
			"\tTrieNode* temp = root;",
			"\tfor (int i = 0; i < key.size(); i++) {",
			"\t\tint index = key[i] - 'a';",
			"\t\tif (temp->children[index] == NULL) {",
			"\t\t\treturn false;",
			"\t\t}",
			"\t\ttemp = temp->children[index];",
			"\t}",
			"\treturn (temp->isEnd);",
			"}",
			""],
		"description": "Trie is a type of k-ary search tree used for storing and searching a specific key from a set. Using Trie, search complexities can be brought to optimal limit (key length). ",
	},
	"Longest Increasing Subsequence":{
		"prefix":["LIS","longestIncreasingSubsequence"],
		"body": [
			"vector<int> v;",
			"",
			"bool compareIndexes(int i, int j) {",
			"\treturn v[i] < v[j];",
			"",
			"}",
			"",
			"vector<int> LIS() {",
			"\t//O(nlogn)",
			"\t//returns the longest increasing subsequence",
			"\tint n = v.size();",
			"\tvector<int> T(n, -1), R(n, -1);",
			"\tint length = 1;",
			"\tT[0] = 0;",
			"\tfor (int i = 1; i < n; i++) {",
			"\t\tif (v[i] < v[T[0]]) {",
			"\t\t\tT[0] = i;",
			"\t\t}",
			"\t\telse if (v[i] > v[T[length - 1]]) {//the subsequence is increasing strictly",
			"\t\t\tR[i] = T[length - 1];",
			"\t\t\tT[length++] = i;",
			"\t\t}",
			"\t\telse {",
			"\t\t\tint index = lower_bound(T.begin(), T.begin() + length, i, compareIndexes) - T.begin();",
			"\t\t\tR[i] = T[index - 1];",
			"\t\t\tT[index] = i;",
			"\t\t}",
			"\t}",
			"\tvector<int> result;",
			"\tfor (int i = T[length - 1]; i >= 0; i = R[i]) {",
			"\t\tresult.push_back(v[i]);",
			"\t}",
			"\treverse(result.begin(), result.end());",
			"\treturn result;",
			"",
			"}"],
		"description": "O(nlogn) algorithm to find the longest increasing subsequence of a given sequence"
	},

	}


